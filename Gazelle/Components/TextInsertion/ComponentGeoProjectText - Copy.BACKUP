using System;
using System.Collections.Generic;
using System.Linq;
using Grasshopper;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using Grasshopper.Kernel.Types;
using Newtonsoft.Json.Linq;
using Rhino.Geometry;
using SferedApi.Datatypes;

namespace SferedApi.Components.Geo
{
    public class ComponentGeoProjectText : GH_Component
    {
        // starting values 
        public double letterWidth;
        public double letterHeight;
        public double letterDepth;

        // constances 
        public const double ClosestPointPrecision = 10.0;
        public const double ProjectionTolerance = 0.000001;
        public const double PreProjectionHoverHeight = -1;

        // settings 
        public List<bool> Settings;

        // Letter Data (oldskool)
        // public JObject letterJsonData;

        // raw letter data / serialized letter data 
        private GH_Structure<IGH_Goo> letterRawData;

        // letter data new 
        private List<FontCustomCharacter> LetterDataList;

        /// <summary>
        /// Initializes a new instance of the MyComponent1 class.
        /// </summary>
        public ComponentGeoProjectText()
          : base(SD.Starter + "Project Text",
                    SD.Starter + "Project Text",
                    SD.CopyRight + "Project a Text to a brep",
                    SD.PluginTitle,
                    SD.PluginCategory5)
        {

            // settings 
            Settings = new List<bool>()
            {
                // setting 1
                false,

                // setting 2
                false,

                // setting 3
                false
            };
            
            // oldskool
            // letterJsonData = JObject.Parse(Properties.Resources.TextInsertJson);
        }

    /// <summary>
    /// Registers all the input parameters for this component.
    /// </summary>
    protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
            // main parameters
            pManager.AddTextParameter("Text", "T", "Text to project. Currenty, only (a,b,c,d,e,f) can be used.", GH_ParamAccess.item);
            pManager.AddBrepParameter("Brep", "B", "Brep to project onto", GH_ParamAccess.item);
            pManager.AddPlaneParameter("Plane", "P", "Plane to project text insertion from ", GH_ParamAccess.item, Plane.WorldXY);

            // letter parameters
            pManager.AddNumberParameter("Width", "W", "Width of Letter",GH_ParamAccess.item, 2.4);
            pManager.AddNumberParameter("Height", "H", "Height of Letter", GH_ParamAccess.item, 2.4);
            pManager.AddNumberParameter("Depth", "D", "Depth of Letter", GH_ParamAccess.item, 0.5);
            
            // additional parameters
            pManager.AddNumberParameter("Options", "O", "Additional settings", GH_ParamAccess.list);

            // temporary parameters
            pManager.AddGenericParameter("Temp", "Temp", "temporary, put the alfabet curves in here", GH_ParamAccess.tree);

            // make some things optional 
            for (int i =0; i < 8; i++)
            {
                pManager[i].Optional = true;
            }
        }

        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddSurfaceParameter("Surfaces","S","Surfaces of the insert", GH_ParamAccess.item);
            pManager.AddCurveParameter("Surrounding curve","C","curve around text, should be closed curve", GH_ParamAccess.item);
            pManager.AddGenericParameter("Debug", "D", "geometry for debugging", GH_ParamAccess.list);
        }

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object is used to retrieve from inputs and store in outputs.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {
            // INPUT -------------------------------------------------------------------------------------------------
            string text = "";
            var brep = new Brep();
            var plane = new Plane();
            DA.GetData(0, ref text);
            DA.GetData(1, ref brep);
            DA.GetData(2, ref plane);

            // INPUT additional
            DA.GetData(3, ref letterWidth);
            DA.GetData(4, ref letterHeight);
            DA.GetData(5, ref letterDepth);
            DA.GetDataList(6, Settings);

            // INPUT temporary
            DA.GetDataTree(7, out letterRawData);

            // test
            Message = "";

            // PROCESS -1 ---------------------------------- load character data (can be optimized)
            LetterDataList = new List<FontCustomCharacter>();
            foreach (var branch in letterRawData.Branches)
            {
                var c = new FontCustomCharacter(branch);
                Message += c.Character;
                LetterDataList.Add(c);

                /*
                catch
                {
                    var realList = new List<object>();
                    foreach (var item in branch)
                    {
                        var goo = item as GH_Goo<object>;
                        realList.Add(goo.Value);
                    }


                    var c = new FontCustomCharacter(realList);
                    Message += c.Character;
                    LetterDataList.Add(c);
                }
                */

            }

            // PROCESS 0 ----------------------------------- get correct positions and transformation data 

            // precalculations
            Vector3d projectionVector = plane.ZAxis;
            double fullWidthOfText = 0;
            plane.Translate(projectionVector * PreProjectionHoverHeight);
            var preProjectionCurves = new DataTree<Curve>();
            double scaleFactor = 0;

            // PROCESS 1 ----------------------------------- get character geometry and move to the correct possition

            // per character in text
            for (int i = 0; i < text.Length; i++)
            {
                // get the letter object corresponding to this character  
                char character = text.ToLower().ToCharArray()[i];
                FontCustomCharacter c = null;
                foreach(var letterData in LetterDataList)
                {
                    if (letterData.Character == character)
                    {
                        c = letterData;
                        break;
                    }
                }

                if (c == null)
                {
                    AddRuntimeMessage(GH_RuntimeMessageLevel.Warning, "Character '" + character.ToString() + "' has no loaded geometry");
                    return;
                }

                // extract data
                List<Curve> charCurves = c.CurveList;
                Point3d charPoint = c.Plane.Origin;
                Plane LetterCurveOriginPlane = c.Plane;

                // each letter needs a different position, make transformation precalculations 
                scaleFactor = letterHeight / c.Height;
                var distanceToMid = fullWidthOfText;
                fullWidthOfText += c.Width;

                // create vectors to correct the position of the curves
                var xMovementToCharPlace = distanceToMid;                      // <-- DIT MOET GEFIXED WORDEN 
                var vector1 = new Vector3d(c.Width / 2, 0, 0);                 // move to the left / right
                var vector2 = new Vector3d(xMovementToCharPlace, 0, 0);        // move to this char's position in word

                // create the transformations necessairy to bring the static letter curves in the correct position, with the correct size
                var planeTransformation = Transform.PlaneToPlane(LetterCurveOriginPlane, plane);

                // dont scale 
                var scaleTransformation = Transform.Scale(LetterCurveOriginPlane, scaleFactor, scaleFactor, 1);

                // place these curves in the correct position for projection
                foreach (var curve in charCurves)
                {
                    curve.Translate(vector1 + vector2);
                    curve.Transform(scaleTransformation);
                    curve.Transform(planeTransformation);
                }

                // add them to tree for test
                foreach (var curve in charCurves)
                {
                    preProjectionCurves.Add(curve, new GH_Path(i));
                }
            }

            // PROCESS 1.5 ------------------------------------------------------------------------------------  bend? 

            // place in center 
            bool centered = true;
            if (centered)
            {
                // the width of the entire text. move the curves
                // Point3d point = plane.Origin + boundingbox.Center * -1;

                Vector3d finalmovevec = plane.XAxis * (fullWidthOfText * scaleFactor * -0.5);
                foreach (var branch in preProjectionCurves.Branches)
                {
                    foreach (var item in branch)
                    {
                        item.Translate(finalmovevec);
                    }
                }

            }


            // PROCESS 2 -------------------------------------------------------------------------- project the curves  

            // the projection must be revamped, we cannot do this anymore on a per letter basis. 

            /* pseudo:
            - Project everything
            - intersect with brep edges. 
                - if intersect with naked edges -> quit or try again with smaller letter height
                - 
             
             */
            
            
            // again, per character
            var resultGeoTree = new DataTree<object>();
            var testGeoTree = new DataTree<object>();
            for (int i = 0; i < text.Length; i++)
            {
                // project the curves    
                var character = text.ToCharArray()[i];
                bool projectSuccess = ProjectCharacter(character, 
                                                       preProjectionCurves.Branches[i], 
                                                       projectionVector, 
                                                       brep, 
                                                       letterDepth, 
                                                       out List<IGH_Goo> resultGeo,
                                                       out List<object> testGeo);
                // dismiss if projection unsuccesful 
                if (!projectSuccess)
                {
                    AddRuntimeMessage(GH_RuntimeMessageLevel.Warning, " geometry of character " + character.ToString() + " failed to project");
                    continue; 
                }

                // add it to collection
                resultGeoTree.Add(resultGeo, new GH_Path(i));
                testGeoTree.Add(testGeo, new GH_Path(i));
            }

            // PROCESS 3 ----------------------------------------------------------------------- section with curves 



            // OUTPUT ------------------------------------------------------------------------------------------------
            DA.SetData(0, resultGeoTree);
            DA.SetData(1, testGeoTree);
            DA.SetDataTree(2, preProjectionCurves);

        }

        #region Local Helpers 

        // with charcurves hovering above the brep, project these curves on the brep, and create the solid letter geometry
        private bool ProjectCharacter(char character, List<Curve> charCurves, Vector3d projectVector, Brep brep, double depth, out List<IGH_Goo> resultGeo, out List<object> testGeo)
        {
            // fill these lists
            var curves1 = new List<Curve>();
            var curves2 = new List<Curve>();
            resultGeo = new List<IGH_Goo>();

            // test
            testGeo = new List<object>();

            // ik wil dat twee aanliggende surfaces dezelfde curve gebruiken. MAAR curves moeten eerst gejoined worden, dan geprojecteerd.


            // STEP 1 - PROJECTION
            foreach (var curve in charCurves)
            {
                // make the actual projection
                var projectedCrvs = Curve.ProjectToBrep(curve, brep, projectVector, ProjectionTolerance);
            }

            // return the geometry list 
            return true;
        }

        /* with charcurves hovering above the brep, project these curves on the brep, and create the solid letter geometry
        private bool ProjectCharacterOLD(char character, List<Curve> charCurves, Vector3d projectVector, Brep brep, double depth, out List<IGH_Goo> resultGeo, out List<object> testGeo)
        {
            // fill these lists
            var curves1 = new List<Curve>();
            var curves2 = new List<Curve>();
            resultGeo = new List<IGH_Goo>();

            // test
            testGeo = new List<object>();

            //  lookup the mapping data for this character. the map is a json, containing the indexes of the curves which should become surfaces 
            var metaKey = "data " + char.ToLower(character);
            var charMap = letterJsonData[metaKey];
            if (charMap == null)
            {
                // conversion failed
                AddRuntimeMessage(GH_RuntimeMessageLevel.Warning, " character " + character.ToString() + " not mapped.");
                return false;
            }

            // ik wil dat twee aanliggende surfaces dezelfde curve gebruiken. MAAR curves moeten eerst gejoined worden, dan geprojecteerd.

            // STEP 1 - PROJECTION
            foreach (var curve in charCurves)
            {
                // make the actual projection
                var projectedCrvs = Curve.ProjectToBrep(curve, brep, projectVector, ProjectionTolerance);

               
            }


            // STEP 2 - MAPPING
            var Keys = new List<string>() { "surface top" , "surface bot" , "loft" , "edges" };
            foreach(string key in Keys)
            {
                JArray list = (JArray)charMap[key];
                ApplyMapToCurves(list, key, brep, projectVector, ProjectionTolerance);
            }

            // test json 
            

            // return the geometry list 
            return true;
        }
        */

        // DONT JUST DELETE THIS: it explains how to use jsons 
        private bool ApplyMapToCurves(JArray jArray, string key, Brep brep, Vector3d vector, double tolerance)
        {

            foreach (JArray sublist in jArray)
            {
                // try to fill this curve with various approaches
                Curve curve;
                if (sublist.Type == JTokenType.Integer)
                {
                    // single int found 

                }
                else if (sublist.Type == JTokenType.Array)
                {
                    // list found 
                    foreach (int subitem in sublist)
                    {
                        Message += " , " + subitem.ToString();
                    }

                }
                else
                {
                    // conversion failed
                    AddRuntimeMessage(GH_RuntimeMessageLevel.Warning, " json couldnt be read.");
                    return false;
                }
            }

            // FAILED
            return false;
        }

        #endregion



        /// <summary>
        /// Provides an Icon for the component.
        /// </summary>
        protected override System.Drawing.Bitmap Icon
        {
            get
            {
                //You can add image files to your project resources and access them like this:
                // return Resources.IconForThisComponent;
                return Properties.Resources.ProjectText;
            }
        }

        /// <summary>
        /// Gets the unique ID for this component. Do not change this ID after release.
        /// </summary>
        public override Guid ComponentGuid
        {
            get { return new Guid("31d8b09a-f539-4ecb-846c-2a90d287e8b8"); }
        }
    }
}