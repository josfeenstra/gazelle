// Generated by .NET Reflector from D:\Sfered\Gazelle\Remnants\SferedApi_brep_manipulation.dll

using Grasshopper.Kernel;
using Rhino.Geometry;
using System;
using System.Collections.Generic;
using System.Drawing;

namespace Gazelle.Components
{
    public class ComponentGeoScalableSpline : GH_Component
    {
        public ComponentGeoScalableSpline() : base(SD.Starter + "Scalable Spline Curve", SD.Starter + "Spline", SD.CopyRight + "Create a curve with a scaled start and end factor. \nThis is a 3rd degree basic spline. \nUse this component if you want a curve with a set start and end factor, but Bezier-like behaviour.", SD.PluginTitle, SD.PluginCategory6)
        {
        }

        private string MakeFactorizedCurve(Point3d A, Point3d B, Vector3d Av, Vector3d Bv, double Af, double Bf, Vector3d Xv, ref object C, ref List<object> P, ref object p, ref object q)
        {
            string str = "";
            Point3d pointd = A;
            Point3d pointd2 = B;
            Vector3d vectord = Av;
            Vector3d vectord2 = Bv;
            Vector3d vectord3 = Xv;
            double num = Af;
            double num2 = Bf;
            vectord.Unitize();
            vectord2.Unitize();
            Plane plane = Plane.Unset;
            if ((vectord3 != Vector3d.Unset) && (vectord3 != Vector3d.Zero))
            {
                plane = new Plane(pointd, vectord, vectord3);
                if (!plane.IsValid)
                {
                    str = "CustomPlane";
                    plane = new Plane(pointd, vectord2, vectord3);
                    if (!plane.IsValid)
                    {
                        plane = new Plane(pointd, vectord, Vector3d.ZAxis);
                        if (!plane.IsValid)
                        {
                            return "ERROR";
                        }
                    }
                }
            }
            else
            {
                plane = new Plane(pointd, vectord, vectord2);
                if (!plane.IsValid)
                {
                    str = "CustomPlane";
                    plane = new Plane(pointd, vectord, Vector3d.ZAxis);
                    if (!plane.IsValid)
                    {
                        plane = new Plane(pointd, vectord, Vector3d.ZAxis);
                        if (!plane.IsValid)
                        {
                            return "ERROR";
                        }
                    }
                }
            }
            double num3 = pointd.DistanceTo(plane.ClosestPoint(pointd2)) / 2.0;
            Point3d pointd4 = pointd + ((vectord * num3) * num);
            Point3d pointd5 = pointd2 + (((vectord2 * num3) * -1.0) * num2);
            Point3d[] pointdArray = new Point3d[] { pointd, pointd4, pointd5, pointd2 };
            NurbsCurve curve = NurbsCurve.Create(false, 3, pointdArray);
            Polyline polyline = new Polyline(pointdArray);
            C = curve;
            object[] collection = new object[] { pointd, pointd4, pointd5, pointd2 };
            P.AddRange(collection);
            q = polyline;
            return str;
        }

        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
            pManager.AddPointParameter("Points", "P", "The Start, End or In between points", GH_ParamAccess.list);
            pManager.AddVectorParameter("Vectors", "V", "The Start, End or In between vectors", GH_ParamAccess.list);
            pManager.AddNumberParameter("Factors", "F", "The Start, End or In between factors", GH_ParamAccess.list, new double[] { 0.8, 0.8 });
            pManager.AddVectorParameter("backup Vector", "r", "if an angle cannot be made between two vectors, use this as a backup vector (a bit weird i know)", 0, Vector3d.ZAxis);
        }

        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddCurveParameter("Curves", "C", "The created curves in between all points", GH_ParamAccess.list);
            pManager.AddPointParameter("Control Points", "P", "The created control points.", GH_ParamAccess.list);
            pManager.AddCurveParameter("Polyline", "Pl", "The Polylines through the control points.", GH_ParamAccess.list);
        }

        protected override void SolveInstance(IGH_DataAccess DA)
        {
            List<Point3d> list = new List<Point3d>();
            List<Vector3d> list2 = new List<Vector3d>();
            List<double> list3 = new List<double>();
            Vector3d xv = Vector3d.Unset;
            DA.GetDataList<Point3d>(0, list);
            DA.GetDataList<Vector3d>(1, list2);
            DA.GetDataList<double>(2, list3);
            DA.GetData<Vector3d>(3, ref xv);
            if (list.Count != list2.Count)
            {
                throw new Exception("Lists must be equal");
            }
            if (((list.Count - 1) * 2) != list3.Count)
            {
                throw new Exception("per pair of points, two vectors are needed.");
            }
            if (list.Count < 2)
            {
                throw new Exception("Need at least 2 points");
            }
            List<object> list4 = new List<object>();
            List<object> p = new List<object>();
            List<object> list6 = new List<object>();
            int num = 0;
            while (true)
            {
                if (num >= (list.Count - 1))
                {
                    DA.SetDataList(0, list4);
                    DA.SetDataList(1, p);
                    DA.SetDataList(2, list6);
                    return;
                }
                object c = null;
                object obj3 = null;
                object q = null;
                this.MakeFactorizedCurve(list[num], list[num + 1], list2[num], list2[num + 1], list3[num * 2], list3[(num * 2) + 1], xv, ref c, ref p, ref obj3, ref q);
                list4.Add(c);
                list6.Add(q);
                num++;
            }
        }

        public override Guid ComponentGuid =>
            new Guid("188007a5-a201-4d35-8d46-f02d68d0b02e");
    }
}
