// Generated by .NET Reflector from D:\Sfered\Gazelle\Remnants\SferedApi_brep_manipulation.dll
namespace SferedApi
{
    using Grasshopper.Kernel.Types;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Linq;
    using Rhino.Geometry;
    using Rhino.Geometry.Collections;
    using Rhino.Geometry.Intersect;
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Runtime.InteropServices;
    
    internal class Helpers
    {
        private bool ApplyMapToCurves(JArray jArray, string key, Brep brep, Vector3d vector, double tolerance)
        {
            using (IEnumerator<JToken> enumerator = jArray.GetEnumerator())
            {
                while (true)
                {
                    if (!enumerator.MoveNext())
                    {
                        break;
                    }
                    JArray current = (JArray) enumerator.Current;
                    if (current.get_Type() != 6)
                    {
                        if (current.get_Type() == 2)
                        {
                            foreach (int num in current)
                            {
                            }
                            continue;
                        }
                        return false;
                    }
                }
                return false;
            }
        }
        
        private int chooseLargestPoint(Point3d point1, Point3d point2) => 
            (point1.get_X() <= point2.get_X()) ? ((point1.get_X() >= point2.get_X()) ? ((point1.get_Y() <= point2.get_Y()) ? ((point1.get_Y() >= point2.get_Y()) ? ((point1.get_Z() <= point2.get_Z()) ? ((point1.get_Z() >= point2.get_Z()) ? 0 : -1) : 1) : -1) : 1) : -1) : 1;
        
        public CurveRelation CompareCurves(Curve curve1, Curve curve2) => 
            ((curve1.Contains(curve2.get_PointAtStart()) != 3) || (curve1.Contains(curve2.get_PointAtEnd()) != 3)) ? CurveRelation.Unequal : CurveRelation.Overlap;
        
        private static bool CurveMatch(BrepTrimList testCurves, List<Curve> controlCurves)
        {
            using (List<Curve>.Enumerator enumerator = controlCurves.GetEnumerator())
            {
                while (true)
                {
                    if (!enumerator.MoveNext())
                    {
                        break;
                    }
                    Curve current = enumerator.Current;
                    bool flag = false;
                    foreach (BrepTrim trim in testCurves)
                    {
                        if ((current == null) || (trim == null))
                        {
                            flag = false;
                        }
                        else
                        {
                            if ((current.Contains(trim.get_PointAtStart()) == 3) && (current.Contains(trim.get_PointAtEnd()) == 3))
                            {
                                flag = true;
                                continue;
                            }
                            flag = false;
                        }
                        break;
                    }
                    if (flag)
                    {
                        return true;
                    }
                }
            }
            return false;
        }
        
        private static Curve[] CutCurveWithCurves(Curve curve, List<Curve> cutterCurves)
        {
            List<double> list2;
            List<Point3d> list3;
            Curve[] curveArray;
            List<string> list4;
            List<IGH_Goo> splitters = new List<IGH_Goo>();
            foreach (Curve curve2 in cutterCurves)
            {
                splitters.Add(new GH_Curve(curve2));
            }
            List<GH_Boolean> options = new List<GH_Boolean>();
            options.Add(new GH_Boolean(false));
            options.Add(new GH_Boolean(false));
            return (CurveFunctions.CutCurves(curve, splitters, options, out list2, out list3, out curveArray, out list4) ? curveArray : null);
        }
        
        private static int GetInitialSurface(BrepFace face, Brep splitted, List<Curve> curves, ref List<object> test)
        {
            int num = -1;
            int num2 = splitted.get_Faces().get_Count();
            List<Curve> list = new List<Curve>();
            foreach (BrepFace face2 in splitted.get_Faces())
            {
                Curve curve = face2.get_OuterLoop().To2dCurve();
                if (curve == null)
                {
                    test.Add("CANT PULL CURVE");
                    continue;
                }
                list.Add(curve);
            }
            Random random = new Random();
            Point3d item = Point3d.get_Unset();
            int num3 = 0;
            int num4 = 100;
            bool flag = true;
            if (flag)
            {
                item = new Point3d(face.Domain(0).ParameterAt(random.NextDouble()), face.Domain(1).ParameterAt(random.NextDouble()), 0.0);
                num = -1;
                flag = false;
                int num5 = 0;
                while (true)
                {
                    bool flag10 = num5 < num2;
                    if (!flag10)
                    {
                        break;
                    }
                    Curve curve2 = list[num5];
                    PointContainment containment = curve2.Contains(item);
                    bool flag3 = containment == 0;
                    if (!flag3)
                    {
                        if (containment == 3)
                        {
                            if (num3 >= num4)
                            {
                                throw new Exception($"the 'get a random point' procedure is past try nr. {num4}");
                            }
                            num3++;
                            flag = true;
                        }
                        if (containment == 1)
                        {
                            if (num == -1)
                            {
                                num = num5;
                            }
                            else if (curve2.GetLength() < list[num].GetLength())
                            {
                                num = num5;
                            }
                        }
                        if (containment == 2)
                        {
                        }
                        num5++;
                        continue;
                    }
                    test.Add("pointContainment is unset, the curve or the point are unworkable!");
                    return -1;
                }
            }
            test.Add("PointOnTrim:");
            test.Add(item);
            test.Add("candidate:");
            test.Add(list[num]);
            return num;
        }
        
        private static bool IsPointOnSurface(Point3d point, BrepFace surface, double tolerance)
        {
            double num;
            double num2;
            surface.ClosestPoint(point, ref num, ref num2);
            Point3d pointd = surface.PointAt(num, num2);
            PointFaceRelation relation = surface.IsPointOnFace(num, num2);
            return (point.DistanceTo(pointd) < tolerance);
        }
        
        public static Dictionary<string, string> JsonToDict(string json) => 
            JsonConvert.DeserializeObject<Dictionary<string, string>>(json);
        
        private static void MapSpace(Brep splitted, List<bool> spaceMapper, bool thisFaceShouldBe, int thisIndex = 0, List<int> alreadyMapped = null)
        {
            if (ReferenceEquals(alreadyMapped, null))
            {
                alreadyMapped = new List<int>();
            }
            if (thisIndex < splitted.get_Faces().get_Count())
            {
                BrepFace face = splitted.get_Faces().get_Item(thisIndex);
                spaceMapper[thisIndex] = thisFaceShouldBe;
                alreadyMapped.Add(thisIndex);
                foreach (int num2 in face.AdjacentFaces())
                {
                    if (!alreadyMapped.Contains(num2))
                    {
                        MapSpace(splitted, spaceMapper, !thisFaceShouldBe, num2, alreadyMapped);
                    }
                }
            }
        }
        
        private static bool OldGetInitialSurface(BrepFace face, Brep splitted, List<Curve> curves, double Tolerance, ref List<object> test, out int chosenID, out bool originalBool)
        {
            test.Add("face:");
            test.Add(face.ToBrep());
            List<Curve> list = new List<Curve>();
            foreach (Curve curve in curves)
            {
                Curve curve2 = face.Pullback(curve, Tolerance);
                if (curve2 == null)
                {
                    test.Add("CANT PULL CURVE");
                    continue;
                }
                list.Add(curve2);
            }
            Point3d item = new Point3d(face.Domain(0).ParameterAt(0.5), face.Domain(1).ParameterAt(0.5), 0.0);
            chosenID = -1;
            foreach (BrepFace face2 in splitted.get_Faces())
            {
                PointFaceRelation relation = face2.IsPointOnFace(item.get_X(), item.get_Y());
                if (relation == 2)
                {
                    test.Add("MIDDLE POINT IS ON EDGE OF (PROBABLY) TWO SURFACES");
                }
                if (relation == 1)
                {
                    chosenID = face2.get_FaceIndex();
                }
            }
            if (chosenID == -1)
            {
                test.Add("point is not on any surface");
            }
            test.Add(item);
            originalBool = true;
            foreach (Curve curve3 in list)
            {
                PointContainment containment = curve3.Contains(item);
                PointContainment containment2 = containment;
                switch (containment2)
                {
                    case 0:
                        test.Add("pointContainment is unset, the curve or the point are unworkable!");
                        break;
                    
                    case 1:
                        originalBool = !originalBool;
                        break;
                    
                    case 3:
                        test.Add("POINT IS ON THE EDGE OF ANOTHER POINT at the pulled curve operation");
                        break;
                    
                    default:
                        break;
                }
                test.Add(curve3);
                test.Add(containment.ToString());
            }
            return true;
        }
        
        public static bool OldPerforateSurface(List<Curve> curves, Brep brep, double Tolerance, out List<Brep> leftover, out List<Brep> holes, out List<object> test)
        {
            bool flag3;
            leftover = new List<Brep>();
            holes = new List<Brep>();
            test = new List<object>();
            if (brep.get_Faces().get_Count() < 1)
            {
                test.Add("brep has no faces");
                flag3 = false;
            }
            else if (brep.get_Faces().get_Count() > 1)
            {
                test.Add("brep should have 1 face, but has multiple (perforate surface)");
                flag3 = false;
            }
            else
            {
                BrepFace face = brep.get_Faces().FirstOrDefault<BrepFace>();
                Curve[] source = Curve.JoinCurves(face.get_OuterLoop().get_Trims());
                Curve curve = source.FirstOrDefault<Curve>();
                if (source.Length != 1)
                {
                    test.Add("brep outline (trim) should be 1 surface (perforate surface)");
                    flag3 = false;
                }
                else
                {
                    List<Curve> list = new List<Curve>();
                    foreach (Curve curve2 in curves)
                    {
                        Curve curve3 = face.Pullback(curve2, Tolerance);
                        if (curve3 == null)
                        {
                            test.Add("CANT PULL CURVE");
                            continue;
                        }
                        list.Add(curve3);
                    }
                    Point3d item = new Point3d(face.Domain(0).ParameterAt(0.5), face.Domain(1).ParameterAt(0.5), 0.0);
                    Brep splitted = face.Split(curves, Tolerance);
                    int thisIndex = -1;
                    foreach (BrepFace face2 in splitted.get_Faces())
                    {
                        PointFaceRelation relation = face2.IsPointOnFace(item.get_X(), item.get_Y());
                        if (relation == 2)
                        {
                            test.Add("MIDDLE POINT IS ON EDGE OF (PROBABLY) TWO SURFACES");
                        }
                        if (relation == 1)
                        {
                            thisIndex = face2.get_FaceIndex();
                        }
                    }
                    if (thisIndex == -1)
                    {
                        test.Add("point is not on any surface");
                    }
                    test.Add(item);
                    bool thisFaceShouldBe = false;
                    foreach (Curve curve4 in list)
                    {
                        PointContainment containment = curve4.Contains(item);
                        PointContainment containment2 = containment;
                        switch (containment2)
                        {
                            case 0:
                                test.Add("pointContainment is unset, the curve or the point are unworkable!");
                                break;
                            
                            case 1:
                                thisFaceShouldBe = false;
                                break;
                            
                            case 2:
                                thisFaceShouldBe = true;
                                break;
                            
                            case 3:
                                test.Add("POINT IS ON THE EDGE OF ANOTHER POINT at the pulled curve operation");
                                break;
                            
                            default:
                                break;
                        }
                        test.Add(curve4);
                        test.Add(containment.ToString());
                    }
                    List<bool> spaceMapper = new List<bool>();
                    foreach (BrepFace face3 in splitted.get_Faces())
                    {
                        spaceMapper.Add(false);
                    }
                    MapSpace(splitted, spaceMapper, thisFaceShouldBe, thisIndex, null);
                    int num2 = 0;
                    while (true)
                    {
                        if (num2 >= splitted.get_Faces().get_Count())
                        {
                            flag3 = true;
                            break;
                        }
                        BrepFace face4 = splitted.get_Faces().get_Item(num2);
                        if (spaceMapper[num2])
                        {
                            leftover.Add(face4.DuplicateFace(false));
                        }
                        else
                        {
                            holes.Add(face4.DuplicateFace(false));
                        }
                        num2++;
                    }
                }
            }
            return flag3;
        }
        
        public static List<List<T>> Pairify<T>(List<T> list)
        {
            List<List<T>> list3;
            List<List<T>> list2 = new List<List<T>>();
            if (list.Count < 2)
            {
                list3 = null;
            }
            else
            {
                int num = 0;
                while (true)
                {
                    if (num >= (list.Count - 1))
                    {
                        list3 = list2;
                        break;
                    }
                    List<T> item = new List<T>();
                    item.Add(list[num]);
                    item.Add(list[num + 1]);
                    list2.Add(item);
                    num++;
                }
            }
            return list3;
        }
        
        public static bool PerforateBrep(List<Curve> cutters, Brep brep, double Tolerance, out List<Brep> leftover, out List<Brep> holes, out List<object> test)
        {
            bool flag2;
            leftover = new List<Brep>();
            holes = new List<Brep>();
            List<Brep> list = new List<Brep>();
            test = new List<object>();
            using (List<Curve>.Enumerator enumerator = cutters.GetEnumerator())
            {
                while (true)
                {
                    if (enumerator.MoveNext())
                    {
                        Curve current = enumerator.Current;
                        if (current.get_IsClosed())
                        {
                            continue;
                        }
                        test.Add("one of the curves is not closed!");
                        flag2 = false;
                    }
                    else
                    {
                        int num = 0;
                        while (true)
                        {
                            if (num >= brep.get_Faces().get_Count())
                            {
                                using (List<Brep>.Enumerator enumerator5 = list.GetEnumerator())
                                {
                                    while (true)
                                    {
                                        if (!enumerator5.MoveNext())
                                        {
                                            break;
                                        }
                                        Brep current = enumerator5.Current;
                                        leftover.Add(current);
                                        using (IEnumerator<BrepFace> enumerator6 = current.get_Faces().GetEnumerator())
                                        {
                                            while (true)
                                            {
                                                if (!enumerator6.MoveNext())
                                                {
                                                    break;
                                                }
                                                BrepFace face2 = enumerator6.Current;
                                                foreach (BrepLoop loop in face2.Loops)
                                                {
                                                    foreach (BrepTrim trim in loop.get_Trims())
                                                    {
                                                        trim.get_Edge().ToNurbsCurve();
                                                    }
                                                }
                                            }
                                            continue;
                                        }
                                    }
                                    return true;
                                }
                            }
                            BrepFace surface = brep.get_Faces().get_Item(num);
                            string str = "Face " + num.ToString() + ": ";
                            List<Brep> list2 = new List<Brep>();
                            List<Brep> list3 = new List<Brep>();
                            List<BrepEdge> list4 = new List<BrepEdge>();
                            List<BrepEdge> list5 = new List<BrepEdge>();
                            int[] numArray = surface.AdjacentEdges();
                            int index = 0;
                            while (true)
                            {
                                if (index < numArray.Length)
                                {
                                    int num3 = numArray[index];
                                    BrepEdge item = brep.get_Edges().get_Item(num3);
                                    EdgeAdjacency adjacency = item.get_Valence();
                                    switch (adjacency)
                                    {
                                        case 0:
                                        case 3:
                                            test.Add(str + "None or nonmanifold edges detected.");
                                            return false;
                                        
                                        case 1:
                                            list5.Add(item);
                                            break;
                                        
                                        case 2:
                                            list4.Add(item);
                                            break;
                                        
                                        default:
                                            break;
                                    }
                                    index++;
                                    continue;
                                }
                                else
                                {
                                    List<Curve> curves = new List<Curve>();
                                    using (List<Curve>.Enumerator enumerator2 = cutters.GetEnumerator())
                                    {
                                        while (true)
                                        {
                                            if (enumerator2.MoveNext())
                                            {
                                                Curve current = enumerator2.Current;
                                                List<IntersectionEvent> list8 = new List<IntersectionEvent>();
                                                foreach (BrepEdge edge2 in list4)
                                                {
                                                    CurveIntersections collection = Intersection.CurveCurve(current, edge2, 0.001, 0.001);
                                                    if ((collection != null) && (collection.get_Count() > 0))
                                                    {
                                                        list8.AddRange(collection);
                                                    }
                                                }
                                                foreach (BrepEdge edge3 in list5)
                                                {
                                                    CurveIntersections collection = Intersection.CurveCurve(current, edge3, 0.001, 0.001);
                                                    if ((collection != null) && (collection.get_Count() > 0))
                                                    {
                                                        test.Add(str + "intersection with naked edge!!");
                                                        list8.AddRange(collection);
                                                    }
                                                }
                                                if (list8.Count <= 0)
                                                {
                                                    if (IsPointOnSurface(current.get_PointAtStart(), surface, 0.001))
                                                    {
                                                        curves.Add(current);
                                                    }
                                                    continue;
                                                }
                                                if ((list8.Count % 2) == 0)
                                                {
                                                    curves.Add(current);
                                                    continue;
                                                }
                                                test.Add(str + "ERROR: An intersection with a closed curve should give two intersections, found " + list8.Count.ToString() + ", perforation cannot continue.");
                                                flag2 = false;
                                            }
                                            else
                                            {
                                                Brep item = surface.ToBrep();
                                                if (curves.Count < 1)
                                                {
                                                    test.Add(str + "no cutters found");
                                                    list.Add(item);
                                                }
                                                else
                                                {
                                                    test.Add(str + "number of cutter curves: " + curves.Count.ToString());
                                                    List<object> list7 = new List<object>();
                                                    bool flag3 = PerforateSurface(curves, item, Tolerance, out list2, out list3, out list7);
                                                    leftover.AddRange(list2);
                                                    holes.AddRange(list3);
                                                    test.AddRange(list7);
                                                }
                                                num++;
                                                continue;
                                            }
                                            break;
                                        }
                                    }
                                }
                                break;
                            }
                            break;
                        }
                        return flag2;
                    }
                    break;
                }
            }
            return flag2;
        }
        
        public static bool PerforateSurface(List<Curve> curves, Brep brep, double Tolerance, out List<Brep> leftover, out List<Brep> holes, out List<object> test)
        {
            bool flag4;
            leftover = new List<Brep>();
            holes = new List<Brep>();
            test = new List<object>();
            if (brep.get_Faces().get_Count() < 1)
            {
                test.Add("brep has no faces");
                flag4 = false;
            }
            else if (brep.get_Faces().get_Count() > 1)
            {
                test.Add("brep should have 1 face, but has multiple (perforate surface)");
                flag4 = false;
            }
            else
            {
                BrepFace face = brep.get_Faces().FirstOrDefault<BrepFace>();
                Curve[] source = Curve.JoinCurves(face.get_OuterLoop().get_Trims());
                Curve curve = source.FirstOrDefault<Curve>();
                if (source.Length != 1)
                {
                    test.Add("brep outline (trim) should be 1 surface (perforate surface)");
                    flag4 = false;
                }
                else
                {
                    bool flag;
                    Brep splitted = face.Split(curves, Tolerance);
                    int chosenID = -1;
                    bool flag2 = OldGetInitialSurface(face, splitted, curves, Tolerance, ref test, out chosenID, out flag);
                    List<bool> spaceMapper = new List<bool>();
                    foreach (BrepFace face2 in splitted.get_Faces())
                    {
                        spaceMapper.Add(false);
                    }
                    MapSpace(splitted, spaceMapper, flag, chosenID, null);
                    int num2 = 0;
                    while (true)
                    {
                        if (num2 >= splitted.get_Faces().get_Count())
                        {
                            flag4 = true;
                            break;
                        }
                        BrepFace face3 = splitted.get_Faces().get_Item(num2);
                        if (spaceMapper[num2])
                        {
                            leftover.Add(face3.DuplicateFace(false));
                        }
                        else
                        {
                            holes.Add(face3.DuplicateFace(false));
                        }
                        num2++;
                    }
                }
            }
            return flag4;
        }
        
        public static void PreProcessTrims(Curve trim, List<Curve> curves, out List<Curve> outLeftovers, out List<Curve> outHoles)
        {
            int nth;
            int wrongNth;
            List<Curve> list = new List<Curve>();
            List<Curve> collection = new List<Curve>();
            bool flag = false;
            List<IntersectionEvent> list3 = new List<IntersectionEvent>();
            foreach (Curve curve in curves)
            {
                RegionContainment containment2 = Curve.PlanarClosedCurveRelationship(trim, curve, Plane.WorldXY, 0.001);
                switch (containment2)
                {
                    case 1:
                    {
                        PointContainment containment3 = curve.Contains(trim.get_PointAtStart());
                        if ((containment3 == 1) || (containment3 == 3))
                        {
                            flag = !flag;
                        }
                        List<Curve> cutterCurves = new List<Curve>();
                        cutterCurves.Add(trim);
                        List<Curve> list6 = new List<Curve>();
                        Curve[] curveArray6 = CutCurveWithCurves(curve, cutterCurves);
                        int index = 0;
                        while (true)
                        {
                            if (index >= curveArray6.Length)
                            {
                                collection.AddRange(Curve.JoinCurves(list6));
                                break;
                            }
                            Curve item = curveArray6[index];
                            PointContainment containment4 = trim.Contains(item.PointAtNormalizedLength(0.5));
                            if (containment4 == 1)
                            {
                                list6.Add(item);
                            }
                            index++;
                        }
                        continue;
                    }
                    case 3:
                    {
                        list.Add(curve);
                        continue;
                    }
                }
            }
            Curve[] source = CutCurveWithCurves(trim, curves);
            if (flag)
            {
                nth = 0;
                wrongNth = 1;
            }
            else
            {
                nth = 1;
                wrongNth = 0;
            }
            List<Curve> list4 = new List<Curve>();
            List<Curve> list5 = new List<Curve>();
            list4.AddRange(collection);
            list4.AddRange(source.Where<Curve>((x, i) => (i % 2) == nth));
            list5.AddRange(collection);
            list5.AddRange(source.Where<Curve>((x, i) => (i % 2) == wrongNth));
            Curve[] curveArray2 = Curve.JoinCurves(list4);
            Curve[] curveArray3 = Curve.JoinCurves(list4);
            outHoles = new List<Curve>();
            outLeftovers = new List<Curve>();
            outHoles.AddRange(curveArray2);
        }
        
        public enum CurveRelation
        {
            Equal,
            Overlap,
            Unequal
        }
    }
}
