// Generated by .NET Reflector from D:\Sfered\Gazelle\Remnants\SferedApi_brep_manipulation.dll
namespace SferedApi
{
    using Rhino.Geometry;
    using Rhino.Geometry.Intersect;
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;
    
    public static class BrepFunctions
    {
        public static List<string> Log = new List<string>();
        
        public static void AddBrep(this Brep brep, Brep other)
        {
            brep.Append(other);
        }
        
        public static int AddCurve2D(this Brep brep, int edge, int loop, out bool isTrimReversedEdge)
        {
            BrepLoop loop2 = brep.Loops.get_Item(loop);
            BrepFace face = loop2.Face;
            Curve curve = brep.Surfaces.get_Item(face.get_SurfaceIndex()).Pullback(brep.get_Edges().get_Item(edge).DuplicateCurve(), 0.001);
            CurveOrientation orientation = (loop2.get_LoopType() != 1) ? ((loop2.get_LoopType() != 2) ? ((CurveOrientation) 0) : ((CurveOrientation) (-1))) : ((CurveOrientation) 1);
            CurveOrientation orientation2 = curve.ClosedCurveOrientation(Plane.get_WorldXY());
            curve.Reverse();
            isTrimReversedEdge = true;
            if (((orientation2 != 1) || (orientation != -1)) ? ((orientation2 == -1) && (orientation == 1)) : true)
            {
                curve.Reverse();
                isTrimReversedEdge = !isTrimReversedEdge;
            }
            return brep.get_Curves2D().Add(curve);
        }
        
        public static int AddEdge(this Brep brep, Curve curve, int vertexFrom, int vertexTo)
        {
            int num = brep.get_Curves3D().Add(curve);
            return brep.get_Edges().Add(vertexFrom, vertexTo, num, 0.001).get_EdgeIndex();
        }
        
        public static int AddFace(this Brep brep, Surface surface)
        {
            int num = brep.AddSurface(surface);
            return brep.get_Faces().Add(num).get_FaceIndex();
        }
        
        public static int AddFace(this Brep brep, int surface, bool orientation = false)
        {
            BrepFace face = brep.get_Faces().Add(surface);
            face.set_OrientationIsReversed(orientation);
            return face.get_FaceIndex();
        }
        
        private static void AddIfNotInOther(this HashSet<int> set, int item, HashSet<int> other)
        {
            if (other.Contains(item))
            {
                Print<string>("OVERLAPPING ITEM THATS UNUSUAL");
            }
            set.Add(item);
        }
        
        public static int AddLoop(this Brep brep, int face, BrepLoopType type)
        {
            BrepFace face2 = brep.get_Faces().get_Item(face);
            return brep.Loops.Add(type, face2).get_LoopIndex();
        }
        
        public static int AddOrientedTrim(Brep brep, int edge, int loop, IsoStatus status, BrepTrimType type)
        {
            int num;
            return AddOrientedTrim(brep, edge, loop, status, type, out num);
        }
        
        public static int AddOrientedTrim(Brep brep, int edge, int loop, IsoStatus status, BrepTrimType type, out int curveID)
        {
            bool flag;
            curveID = brep.AddCurve2D(edge, loop, out flag);
            return brep.AddTrim(edge, loop, flag, curveID, status, type);
        }
        
        public static int AddTrim(this Brep brep, int edge, int loop, bool isTrimReversedEdge, int curve2D, IsoStatus status, BrepTrimType type)
        {
            BrepEdge edge2 = brep.get_Edges().get_Item(edge);
            BrepLoop loop2 = brep.Loops.get_Item(loop);
            BrepFace face = loop2.Face;
            Surface surface = brep.Surfaces.get_Item(face.get_SurfaceIndex());
            BrepTrim trim = brep.get_Trims().Add(edge2, isTrimReversedEdge, loop2, curve2D);
            trim.set_IsoStatus(status);
            trim.set_TrimType(type);
            trim.SetTolerances(0.001, 0.001);
            return trim.get_TrimIndex();
        }
        
        public static int AddTrimDepricated(this Brep brep, int edge, int loop, bool isTrimReversedEdge, bool flipTrim, IsoStatus status, BrepTrimType type)
        {
            BrepEdge edge2 = brep.get_Edges().get_Item(edge);
            BrepLoop loop2 = brep.Loops.get_Item(loop);
            BrepFace face = loop2.Face;
            Curve curve = brep.Surfaces.get_Item(face.get_SurfaceIndex()).Pullback(edge2.DuplicateCurve(), 0.001);
            if (flipTrim)
            {
                curve.Reverse();
            }
            BrepTrim trim = brep.get_Trims().Add(edge2, isTrimReversedEdge, loop2, brep.get_Curves2D().Add(curve));
            trim.set_IsoStatus(status);
            trim.set_TrimType(type);
            trim.SetTolerances(0.001, 0.001);
            return trim.get_TrimIndex();
        }
        
        public static int AddVertex(this Brep brep, Point3d point) => 
            brep.get_Vertices().Add(point, 0.0).get_VertexIndex();
        
        public static void AppendAt(this Brep brep, Brep other, Dictionary<int, int> edgeMap)
        {
            using (IEnumerator<BrepFace> enumerator = other.get_Faces().GetEnumerator())
            {
                while (true)
                {
                    if (!enumerator.MoveNext())
                    {
                        break;
                    }
                    BrepFace current = enumerator.Current;
                    foreach (BrepLoop loop in current.Loops)
                    {
                        foreach (BrepTrim trim in loop.get_Trims())
                        {
                        }
                    }
                }
            }
        }
        
        public static int BuildInnerFace(this Brep brep, int face, Curve curve)
        {
            int num = brep.BuildInnerLoop(face, curve, 2);
            BrepTrim trim = brep.get_Trims().get_Item(num);
            BrepFace face2 = trim.get_Loop().Face;
            Surface surface = brep.Surfaces.get_Item(face2.get_SurfaceIndex());
            int edge = trim.get_Edge().get_EdgeIndex();
            int num3 = brep.AddFace(face2.get_SurfaceIndex(), false);
            int num5 = AddOrientedTrim(brep, edge, brep.AddLoop(num3, 1), 0, 2);
            return num3;
        }
        
        private static int BuildInnerFace(ref Brep brep, int face, int edge)
        {
            int num2;
            int num = brep.BuildInnerLoop(face, edge, 2, out num2);
            BrepTrim trim = brep.get_Trims().get_Item(num);
            BrepFace face2 = trim.get_Loop().Face;
            Surface surface = brep.Surfaces.get_Item(face2.get_SurfaceIndex());
            int num3 = trim.get_Edge().get_EdgeIndex();
            int num4 = brep.AddFace(face2.get_SurfaceIndex(), false);
            int num6 = AddOrientedTrim(brep, num3, brep.AddLoop(num4, 1), 0, 2);
            return num4;
        }
        
        public static int BuildInnerFacePreservingCurve(this Brep brep, int face, Curve curve)
        {
            int num2;
            int num = brep.BuildInnerLoop(face, curve, 2, out num2);
            BrepTrim trim = brep.get_Trims().get_Item(num);
            BrepFace face2 = trim.get_Loop().Face;
            Surface surface = brep.Surfaces.get_Item(face2.get_SurfaceIndex());
            int edge = trim.get_Edge().get_EdgeIndex();
            int num4 = brep.AddFace(face2.get_SurfaceIndex(), false);
            int num6 = brep.AddTrim(edge, brep.AddLoop(num4, 1), trim.IsReversed(), num2, 0, 2);
            return num4;
        }
        
        public static List<int> BuildInnerFaces(this Brep brep, int face, List<Curve> curves)
        {
            int[] source = new int[curves.Count];
            for (int i = 0; i < curves.Count; i++)
            {
                source[i] = brep.BuildInnerFace(face, curves[i]);
            }
            return source.ToList<int>();
        }
        
        public static int BuildInnerLoop(this Brep brep, int face, Curve curve, BrepTrimType type = 1)
        {
            int num;
            return brep.BuildInnerLoop(face, curve, type, out num);
        }
        
        public static int BuildInnerLoop(this Brep brep, int face, Curve curve, BrepTrimType type, out int curveID)
        {
            if (!curve.get_IsClosed())
            {
                throw new Exception("Curve is not closed");
            }
            int vertexFrom = brep.AddVertex(curve.get_PointAtStart());
            int edge = brep.AddEdge(curve, vertexFrom, vertexFrom);
            int num3 = face;
            return AddOrientedTrim(brep, edge, brep.AddLoop(num3, 2), 0, type, out curveID);
        }
        
        public static int BuildInnerLoop(this Brep brep, int face, int edge, BrepTrimType type, out int curveID)
        {
            int num = edge;
            int num2 = face;
            return AddOrientedTrim(brep, num, brep.AddLoop(num2, 2), 0, type, out curveID);
        }
        
        public static List<int> BuildInnerLoops(this Brep brep, int face, List<Curve> curves, BrepTrimType type = 1)
        {
            int[] source = new int[curves.Count];
            for (int i = 0; i < curves.Count; i++)
            {
                source[i] = brep.BuildInnerLoop(face, curves[i], type);
            }
            return source.ToList<int>();
        }
        
        public static int CopyTrimWithCurve(Brep brep, BrepTrim original)
        {
            double num2;
            double num3;
            int num = brep.AddTrimCurve(original.DuplicateCurve());
            BrepTrim trim = brep.get_Trims().Add(original.get_Edge(), original.IsReversed(), original.get_Loop(), num);
            trim.set_IsoStatus(original.get_IsoStatus());
            trim.set_TrimType(trim.get_TrimType());
            trim.GetTolerances(ref num2, ref num3);
            double num4 = 1E-07;
            if (num2 < num4)
            {
                num2 = num4;
            }
            if (num3 < num4)
            {
                num3 = num4;
            }
            trim.SetTolerances(num2, num3);
            return trim.get_TrimIndex();
        }
        
        public static void CullUnusedEverything(this Brep brep)
        {
            brep.Compact();
        }
        
        public static Brep DeepCopy(Brep original, double precision)
        {
            Brep brep = new Brep();
            foreach (Surface surface in original.Surfaces)
            {
                brep.AddSurface(surface.Duplicate() as Surface);
            }
            foreach (BrepVertex vertex in original.get_Vertices())
            {
                brep.get_Vertices().Add(vertex.get_Location(), precision);
            }
            foreach (BrepEdge edge in original.get_Edges())
            {
                brep.AddEdge(edge.DuplicateCurve(), edge.get_StartVertex().get_VertexIndex(), edge.get_EndVertex().get_VertexIndex());
            }
            foreach (BrepFace face in original.get_Faces())
            {
                brep.AddFace(face.get_SurfaceIndex(), face.get_OrientationIsReversed());
            }
            foreach (BrepLoop loop in original.Loops)
            {
                brep.AddLoop(loop.Face.get_FaceIndex(), loop.get_LoopType());
            }
            foreach (BrepTrim trim in original.get_Trims())
            {
                CopyTrimWithCurve(brep, trim);
            }
            return brep;
        }
        
        public static Brep DeselectFaces(this Brep brep, List<int> faces)
        {
            List<int> list = new List<int>();
            for (int i = 0; i < brep.get_Faces().get_Count(); i++)
            {
                if (!faces.Contains(i))
                {
                    list.Add(i);
                }
            }
            return brep.SelectFaces(list);
        }
        
        public static void DetectInsertions(Brep brep, out int[] innerFaces, out int[] outerFaces)
        {
            Flush();
            HashSet<int> inner = new HashSet<int>();
            HashSet<int> outer = new HashSet<int>();
            HashSet<int> set = new HashSet<int>();
            foreach (BrepEdge edge in brep.get_Edges())
            {
                Print<string>($"edge: {edge.get_EdgeIndex()}");
                if (edge.get_Valence() == 2)
                {
                    int[] numArray = edge.TrimIndices();
                    if (numArray.Length != 2)
                    {
                        Print<string>("Not two trims");
                        continue;
                    }
                    BrepTrim trim = brep.get_Trims().get_Item(numArray[0]);
                    BrepTrim trim2 = brep.get_Trims().get_Item(numArray[1]);
                    if (trim.Face == trim2.Face)
                    {
                        Print<string>("Same Face");
                        continue;
                    }
                    if (trim.Face.get_SurfaceIndex() == trim2.Face.get_SurfaceIndex())
                    {
                        bool flag = trim.IsReversed();
                        if (flag == trim2.IsReversed())
                        {
                            Print<string>("SAME ORIENTATION THATS UNUSUAL");
                            continue;
                        }
                        set.Add(trim.Face.get_FaceIndex());
                        set.Add(trim2.Face.get_FaceIndex());
                        if (flag)
                        {
                            inner.AddIfNotInOther(trim2.Face.get_FaceIndex(), outer);
                            outer.AddIfNotInOther(trim.Face.get_FaceIndex(), inner);
                            continue;
                        }
                        inner.AddIfNotInOther(trim.Face.get_FaceIndex(), outer);
                        outer.AddIfNotInOther(trim2.Face.get_FaceIndex(), inner);
                    }
                }
            }
            foreach (BrepFace face in brep.get_Faces())
            {
                if (!set.Contains(face.get_FaceIndex()))
                {
                    Func<int, bool> <>9__1;
                    Func<int, bool> <>9__0;
                    Print<string>("Leftover: " + face.get_FaceIndex().ToString());
                    Func<int, bool> predicate = <>9__0;
                    if (<>9__0 == null)
                    {
                        Func<int, bool> local1 = <>9__0;
                        predicate = <>9__0 = x => !outer.Contains(x);
                    }
                    if (face.AdjacentFaces().All<int>(predicate))
                    {
                        inner.Add(face.get_FaceIndex());
                    }
                    Func<int, bool> func4 = <>9__1;
                    if (<>9__1 == null)
                    {
                        Func<int, bool> local2 = <>9__1;
                        func4 = <>9__1 = x => !inner.Contains(x);
                    }
                    if (face.AdjacentFaces().All<int>(func4))
                    {
                        outer.Add(face.get_FaceIndex());
                    }
                }
            }
            innerFaces = inner.ToArray<int>();
            outerFaces = outer.ToArray<int>();
        }
        
        public static void EmbedCurves(ref Brep brep, List<Curve> curves, out List<List<int>> edges, out List<int> faces)
        {
            int num = brep.get_Edges().get_Count();
            int num3 = num + curves.Count;
            edges = new List<List<int>>();
            faces = new List<int>();
            foreach (Curve curve in curves)
            {
                int vertexFrom = brep.AddVertex(curve.get_PointAtStart());
                int num5 = brep.AddEdge(curve, vertexFrom, vertexFrom);
            }
            Dictionary<int, EdgeSplitter> dictionary = new Dictionary<int, EdgeSplitter>();
            int edge = num;
            while (true)
            {
                bool flag;
                int num7;
                while (true)
                {
                    if (edge < num3)
                    {
                        flag = true;
                        num7 = 0;
                        break;
                    }
                    foreach (int num9 in dictionary.Keys)
                    {
                        dictionary[num9].Split();
                    }
                    TrueClean(ref brep);
                    return;
                }
                while (true)
                {
                    if (num7 >= num)
                    {
                        if (flag)
                        {
                            int face = brep.PointOnFace(brep.get_Edges().get_Item(edge).get_PointAtStart());
                            if (face != -1)
                            {
                                faces.Add(BuildInnerFace(ref brep, face, edge));
                            }
                        }
                        edge++;
                        break;
                    }
                    CurveIntersections intersections = Intersection.CurveCurve(brep.get_Edges().get_Item(edge), brep.get_Edges().get_Item(num7), 0.001, 0.001);
                    if (intersections.get_Count() > 0)
                    {
                        flag = false;
                        if (!dictionary.ContainsKey(edge))
                        {
                            dictionary[edge] = new EdgeSplitter(brep, edge, true);
                        }
                        if (!dictionary.ContainsKey(num7))
                        {
                            dictionary[num7] = new EdgeSplitter(brep, num7, false);
                        }
                        foreach (IntersectionEvent event2 in intersections)
                        {
                            dictionary[edge].AddIntersect(dictionary[num7], event2);
                        }
                    }
                    num7++;
                }
            }
        }
        
        public static Brep EmbedCurvesBeun(Brep brep, List<Curve> curves)
        {
            List<Brep> list = new List<Brep>();
            foreach (BrepFace face in brep.get_Faces())
            {
                Brep item = face.Split(curves, 0.001);
                list.Add(item);
            }
            Brep[] brepArray = Brep.JoinBreps(list, 0.001);
            if (brepArray.Length != 1)
            {
                throw new Exception("Joined brep is loose!");
            }
            return brepArray[0];
        }
        
        public static Brep EmbedCurvesOnFace(Brep brep, List<Curve> curves, int FaceIndex) => 
            null;
        
        private static List<int> EmbedCurvesToFace(Brep brep, List<Curve> curves, int face) => 
            new List<int>();
        
        public static void Extrude(this Brep brep, Vector3d direction)
        {
            List<int> list;
            List<int> list2;
            List<bool> list3;
            int num = brep.get_Vertices().get_Count();
            int num2 = brep.get_Edges().get_Count();
            brep.GetNakedItems(out list, out list2, out list3);
            Brep brep2 = brep.DuplicateBrep();
            brep2.Translate(direction);
            brep2.get_Faces().Flip(false);
            brep.Append(brep2);
            int num3 = 0;
            while (true)
            {
                if (num3 >= list.Count)
                {
                    TrueClean(ref brep);
                    return;
                }
                int num4 = list[num3];
                int num5 = num4 + num2;
                bool flag = list3[num3];
                brep.get_Faces().AddRuledFace(brep.get_Edges().get_Item(num4), flag, brep.get_Edges().get_Item(num5), flag);
                num3++;
            }
        }
        
        public static Brep ExtrudeFaces(this Brep brep, List<int> faces, Vector3d direction)
        {
            brep = brep.DuplicateBrep();
            int num = brep.get_Edges().get_Count();
            int num2 = brep.get_Faces().get_Count();
            List<int> faceEdges = brep.GetFaceEdges(faces);
            Brep brep2 = brep.DuplicateBrep();
            Brep brep3 = brep.SelectFaces(faces);
            brep2.Translate(direction);
            brep.Append(brep2);
            int num3 = 0;
            while (true)
            {
                if (num3 >= faceEdges.Count)
                {
                    List<int> collection = new List<int>();
                    int item = 0;
                    while (true)
                    {
                        if (item >= num2)
                        {
                            faces.AddRange(collection);
                            brep = brep.DeselectFaces(faces);
                            return brep;
                        }
                        if (!faces.Contains(item))
                        {
                            collection.Add(item + num2);
                        }
                        item++;
                    }
                }
                int num4 = faceEdges[num3];
                int num5 = num + num4;
                BrepEdge edge = brep.get_Edges().get_Item(num4);
                BrepEdge edge2 = brep.get_Edges().get_Item(num5);
                bool flag = false;
                if ((edge2.get_TrimCount() == 1) && (brep.get_Trims().get_Item(edge2.TrimIndices()[0]).get_Loop().get_LoopType() == 2))
                {
                    flag = true;
                }
                brep.get_Faces().AddRuledFace(edge, flag, edge2, flag);
                num3++;
            }
        }
        
        public static void ExtrudeNoCap(this Brep brep, Vector3d direction)
        {
            List<int> list;
            List<int> list2;
            List<bool> list3;
            int num = brep.get_Vertices().get_Count();
            int num2 = brep.get_Edges().get_Count();
            int num3 = brep.get_Faces().get_Count();
            brep.GetNakedItems(out list, out list2, out list3);
            Brep brep2 = brep.DuplicateBrep();
            brep2.Translate(direction);
            brep2.get_Faces().Flip(false);
            brep.Append(brep2);
            int num4 = 0;
            while (true)
            {
                if (num4 >= list.Count)
                {
                    List<int> faces = new List<int>();
                    int item = num3;
                    while (true)
                    {
                        if (item >= brep.get_Faces().get_Count())
                        {
                            brep = brep.SelectFaces(faces);
                            TrueClean(ref brep);
                            return;
                        }
                        faces.Add(item);
                        item++;
                    }
                }
                int num5 = list[num4];
                int num6 = num5 + num2;
                bool flag = list3[num4];
                brep.get_Faces().AddRuledFace(brep.get_Edges().get_Item(num5), flag, brep.get_Edges().get_Item(num6), flag);
                num4++;
            }
        }
        
        public static BrepFace FlipAFace(BrepFace face)
        {
            face.set_OrientationIsReversed(!face.get_OrientationIsReversed());
            return face;
        }
        
        public static Brep FlipFace(Brep brep, int i)
        {
            brep.get_Faces().get_Item(i).set_OrientationIsReversed(!brep.get_Faces().get_Item(i).get_OrientationIsReversed());
            return brep;
        }
        
        public static Brep FlipFaces(Brep brep, List<int> faceInts)
        {
            foreach (int num in faceInts)
            {
                FlipFace(brep, num);
            }
            return brep;
        }
        
        private static void Flush()
        {
            Log = new List<string>();
        }
        
        public static List<int> GetFaceEdges(this Brep brep, List<int> faces)
        {
            HashSet<int> source = new HashSet<int>();
            foreach (int num in faces)
            {
                BrepFace face = brep.get_Faces().get_Item(num);
                foreach (int num3 in face.AdjacentEdges())
                {
                    BrepEdge edge = brep.get_Edges().get_Item(num3);
                    int[] numArray2 = edge.AdjacentFaces();
                    if (edge.get_Valence() == 1)
                    {
                        source.Add(num3);
                    }
                    else
                    {
                        Func<int, bool> <>9__0;
                        Func<int, bool> predicate = <>9__0;
                        if (<>9__0 == null)
                        {
                            Func<int, bool> local1 = <>9__0;
                            predicate = <>9__0 = x => faces.Contains(x);
                        }
                        if (!numArray2.All<int>(predicate))
                        {
                            source.Add(num3);
                        }
                    }
                }
            }
            return source.ToList<int>();
        }
        
        public static List<int> GetFacesToFlip(Brep brep, int faceStart)
        {
            List<int> list = new List<int>();
            Queue<Tuple<int, bool>> queue = new Queue<Tuple<int, bool>>();
            HashSet<int> set = new HashSet<int>();
            queue.Enqueue(new Tuple<int, bool>(faceStart, false));
            while (queue.Count > 0)
            {
                Tuple<int, bool> tuple = queue.Dequeue();
                int item = tuple.Item1;
                bool flag = tuple.Item2;
                set.Add(item);
                Print<string>($"visiting face {item}. this face must be flipped : {flag}");
                if (flag)
                {
                    list.Add(item);
                }
                BrepFace face = brep.get_Faces().get_Item(item);
                int[] second = face.AdjacentEdges();
                foreach (int num3 in face.AdjacentFaces())
                {
                    if (!set.Contains(num3))
                    {
                        IEnumerable<int> source = brep.get_Faces().get_Item(num3).AdjacentEdges().Intersect<int>(second);
                        if (source.Count<int>() == 1)
                        {
                            bool flag3;
                            int num4 = source.FirstOrDefault<int>();
                            if (!IsEdgeOrientationBoundary(brep.get_Edges().get_Item(num4)))
                            {
                                flag3 = flag;
                            }
                            else
                            {
                                Print<string>("found orientation boundary!");
                                flag3 = !flag;
                            }
                            Print<string>($"adding neighbour {num3}. this face must be flipped : {flag3}");
                            queue.Enqueue(new Tuple<int, bool>(num3, flag3));
                            set.Add(num3);
                        }
                    }
                }
            }
            return list;
        }
        
        public static void GetNakedItems(this Brep brep, out List<int> edges)
        {
            edges = new List<int>();
            foreach (BrepEdge edge in brep.get_Edges())
            {
                if (edge.get_Valence() == 1)
                {
                    edges.Add(edge.get_EdgeIndex());
                }
            }
        }
        
        public static void GetNakedItems(this Brep brep, out List<int> edges, out List<int> vertices, out List<bool> edgeFlags)
        {
            edges = new List<int>();
            edgeFlags = new List<bool>();
            HashSet<int> source = new HashSet<int>();
            foreach (BrepEdge edge in brep.get_Edges())
            {
                if (edge.get_Valence() == 1)
                {
                    bool item = brep.get_Trims().get_Item(edge.TrimIndices()[0]).get_Loop().get_LoopType() == 1;
                    edges.Add(edge.get_EdgeIndex());
                    edgeFlags.Add(item);
                    source.Add(edge.get_StartVertex().get_VertexIndex());
                    source.Add(edge.get_EndVertex().get_VertexIndex());
                }
            }
            vertices = source.ToList<int>();
        }
        
        public static List<int> GetOrientationBoundaryEdges(Brep brep)
        {
            List<int> list = new List<int>();
            foreach (BrepEdge edge in brep.get_Edges())
            {
                if (IsEdgeOrientationBoundary(edge))
                {
                    list.Add(edge.get_EdgeIndex());
                }
            }
            return list;
        }
        
        public static bool IsEdgeOrientationBoundary(BrepEdge edge)
        {
            bool flag4;
            int[] source = edge.TrimIndices();
            if (source.Count<int>() != 2)
            {
                Print<string>("GetOrientationBoundaryEdges found an edge with more than 2 trims.");
                flag4 = false;
            }
            else
            {
                BrepTrim trim = edge.get_Brep().get_Trims().get_Item(source[0]);
                BrepTrim trim2 = edge.get_Brep().get_Trims().get_Item(source[1]);
                if (((trim.get_Loop().get_LoopType() != 1) || (trim2.get_Loop().get_LoopType() != 2)) ? ((trim.get_Loop().get_LoopType() == 2) && (trim2.get_Loop().get_LoopType() == 1)) : true)
                {
                }
                bool flag = trim.IsReversed();
                if (trim.get_Loop().Face.get_OrientationIsReversed())
                {
                    flag = !flag;
                }
                bool flag2 = trim2.IsReversed();
                if (trim2.get_Loop().Face.get_OrientationIsReversed())
                {
                    flag2 = !flag2;
                }
                flag4 = flag == flag2;
            }
            return flag4;
        }
        
        public static Brep Join(this IEnumerable<Brep> breps)
        {
            Brep[] brepArray = Brep.JoinBreps(breps, 0.001);
            if (brepArray.Length != 1)
            {
                throw new Exception("join failed.");
            }
            return brepArray[0];
        }
        
        public static void JoinEdges(this Brep brep, int edgeIndex1, int edgeIndex2)
        {
            BrepEdge edge = brep.get_Edges().get_Item(edgeIndex1);
            foreach (int num2 in brep.get_Edges().get_Item(edgeIndex2).TrimIndices())
            {
                BrepTrim trim = brep.get_Trims().get_Item(num2);
            }
        }
        
        public static Brep JoinNakedEdges(Brep original)
        {
            Brep brep = DeepCopy(original, 0.001);
            brep.JoinNakedEdges(0.001);
            return brep;
        }
        
        private static List<T> NotIn<T>(List<T> one, List<T> two)
        {
            List<T> list = new List<T>();
            for (int i = 0; i < one.Count; i++)
            {
                if (!two.Contains(one[i]))
                {
                    list.Add(one[i]);
                }
            }
            return list;
        }
        
        public static Brep[] PartitionFaces(this Brep brep, List<int> faces) => 
            new Brep[] { brep.SelectFaces(faces), brep.DeselectFaces(faces) };
        
        public static int PointOnFace(this Brep brep, Point3d point)
        {
            using (IEnumerator<BrepFace> enumerator = brep.get_Faces().GetEnumerator())
            {
                while (true)
                {
                    double num;
                    double num2;
                    if (!enumerator.MoveNext())
                    {
                        break;
                    }
                    BrepFace current = enumerator.Current;
                    bool flag = brep.Surfaces.get_Item(current.get_SurfaceIndex()).ClosestPoint(point, ref num, ref num2);
                    if (flag && (current.IsPointOnFace(num, num2) == 1))
                    {
                        return current.get_FaceIndex();
                    }
                }
            }
            return -1;
        }
        
        private static void Print<T>(T obj)
        {
            Log.Add(obj.ToString());
        }
        
        public static void ProjectEmbed(Brep brep, List<Curve> curves, Vector3d vector, out Brep[] result)
        {
            List<Brep> list = new List<Brep>();
            int num = 0;
            while (true)
            {
                int[] numArray;
                int[] numArray2;
                if (num >= brep.get_Faces().get_Count())
                {
                    result = Brep.JoinBreps(list, 0.001);
                    return;
                }
                BrepFace face = brep.get_Faces().get_Item(num);
                Brep item = brep.SelectFace(num);
                Brep[] brepArray1 = new Brep[] { item };
                Curve[] curveArray = Curve.ProjectToBrep(curves, brepArray1, vector, 0.001, ref numArray, ref numArray2);
                Brep brep3 = item.get_Faces().get_Item(0).Split(curveArray, 0.001);
                if (brep3 == null)
                {
                    list.Add(item);
                }
                else
                {
                    list.Add(brep3);
                }
                num++;
            }
        }
        
        public static void RemoveEdge(this Brep brep, int edgeIndex, bool recurse = false)
        {
        }
        
        public static void RemoveFace(this Brep brep, int face)
        {
            throw new NotImplementedException();
        }
        
        public static void RemoveFace(this Brep brep, int faceIndex, bool recurse = false)
        {
        }
        
        public static void RemoveFaces(this Brep brep, List<int> faces)
        {
            throw new NotImplementedException();
        }
        
        public static void RemoveLoop(this Brep brep, int loopIndex, bool recurse = false)
        {
        }
        
        public static void RemoveTrim(this Brep brep, int trimIndex, bool recurse = false)
        {
        }
        
        public static void RemoveVertex(this Brep brep, int vertexIndex, bool recurse = false)
        {
        }
        
        public static Brep ReorientFaces(Brep original, int faceStart)
        {
            Brep brep = DeepCopy(original, 0.001);
            FlipFaces(brep, GetFacesToFlip(brep, faceStart));
            return brep;
        }
        
        public static Brep SelectFace(this Brep brep, int face)
        {
            int[] numArray1 = new int[] { face };
            return brep.DuplicateSubBrep(numArray1);
        }
        
        public static Brep SelectFaces(this Brep brep, List<int> faces) => 
            brep.DuplicateSubBrep(faces);
        
        public static Brep SelectFacesDepri(this Brep oldBrep, List<int> faces)
        {
            Brep brep = new Brep();
            Dictionary<int, int> dictionary = new Dictionary<int, int>();
            Dictionary<int, int> dictionary2 = new Dictionary<int, int>();
            Dictionary<int, int> dictionary3 = new Dictionary<int, int>();
            using (List<int>.Enumerator enumerator = faces.GetEnumerator())
            {
                while (true)
                {
                    if (!enumerator.MoveNext())
                    {
                        break;
                    }
                    int current = enumerator.Current;
                    BrepFace face = oldBrep.get_Faces().get_Item(current);
                    int key = face.get_SurfaceIndex();
                    if (!dictionary3.ContainsKey(key))
                    {
                        dictionary3.Add(key, brep.AddSurface(face.DuplicateSurface()));
                    }
                    int num3 = brep.AddFace(dictionary3[key], false);
                    foreach (BrepLoop loop in face.Loops)
                    {
                        int num5 = brep.AddLoop(num3, loop.get_LoopType());
                        foreach (BrepTrim trim in loop.get_Trims())
                        {
                            BrepVertex[] vertexArray = new BrepVertex[] { trim.get_Edge().get_StartVertex(), trim.get_Edge().get_EndVertex() };
                            int index = 0;
                            while (true)
                            {
                                if (index >= vertexArray.Length)
                                {
                                    BrepEdge edge = trim.get_Edge();
                                    int num6 = edge.get_EdgeIndex();
                                    if (!dictionary2.ContainsKey(num6))
                                    {
                                        int vertexFrom = dictionary[edge.get_StartVertex().get_VertexIndex()];
                                        dictionary2.Add(num6, brep.AddEdge(edge.DuplicateCurve(), vertexFrom, dictionary[edge.get_EndVertex().get_VertexIndex()]));
                                    }
                                    int num7 = AddOrientedTrim(brep, dictionary2[num6], num5, trim.get_IsoStatus(), trim.get_TrimType());
                                    break;
                                }
                                BrepVertex vertex = vertexArray[index];
                                if (!dictionary.ContainsKey(vertex.get_VertexIndex()))
                                {
                                    int num9 = brep.AddVertex(vertex.get_Location());
                                    dictionary.Add(vertex.get_VertexIndex(), num9);
                                }
                                index++;
                            }
                        }
                    }
                }
            }
            return brep;
        }
        
        public static Brep SelectFacesDepricated(this Brep oldBrep, List<int> faces)
        {
            Brep brep = new Brep();
            Dictionary<int, int> dictionary = new Dictionary<int, int>();
            Dictionary<int, int> dictionary2 = new Dictionary<int, int>();
            Dictionary<int, int> dictionary3 = new Dictionary<int, int>();
            using (List<int>.Enumerator enumerator = faces.GetEnumerator())
            {
                while (true)
                {
                    if (!enumerator.MoveNext())
                    {
                        break;
                    }
                    int current = enumerator.Current;
                    BrepFace face = oldBrep.get_Faces().get_Item(current);
                    int key = face.get_SurfaceIndex();
                    if (!dictionary3.ContainsKey(key))
                    {
                        dictionary3.Add(key, brep.AddSurface(face.DuplicateSurface()));
                    }
                    int num3 = brep.AddFace(dictionary3[key], false);
                    foreach (BrepLoop loop in face.Loops)
                    {
                        int num5 = brep.AddLoop(num3, loop.get_LoopType());
                        foreach (BrepTrim trim in loop.get_Trims())
                        {
                            BrepVertex[] vertexArray = new BrepVertex[] { trim.get_Edge().get_StartVertex(), trim.get_Edge().get_EndVertex() };
                            int index = 0;
                            while (true)
                            {
                                if (index >= vertexArray.Length)
                                {
                                    BrepEdge edge = trim.get_Edge();
                                    int num6 = edge.get_EdgeIndex();
                                    if (!dictionary2.ContainsKey(num6))
                                    {
                                        int vertexFrom = dictionary[edge.get_StartVertex().get_VertexIndex()];
                                        dictionary2.Add(num6, brep.AddEdge(edge.DuplicateCurve(), vertexFrom, dictionary[edge.get_EndVertex().get_VertexIndex()]));
                                    }
                                    int num7 = AddOrientedTrim(brep, dictionary2[num6], num5, trim.get_IsoStatus(), trim.get_TrimType());
                                    break;
                                }
                                BrepVertex vertex = vertexArray[index];
                                if (!dictionary.ContainsKey(vertex.get_VertexIndex()))
                                {
                                    int num9 = brep.AddVertex(vertex.get_Location());
                                    dictionary.Add(vertex.get_VertexIndex(), num9);
                                }
                                index++;
                            }
                        }
                    }
                }
            }
            return brep;
        }
        
        public static void SplitSingularLoopsIntoTwo(this Brep brep)
        {
            List<int> list = new List<int>();
            int num = brep.Loops.get_Count() - 1;
            while (true)
            {
                if (num <= -1)
                {
                    brep.Standardize();
                    return;
                }
                BrepLoop loop = brep.Loops.get_Item(num);
                if (loop.get_Trims().get_Count() == 1)
                {
                    BrepEdge edge = loop.get_Trims().get_Item(0).get_Edge();
                    double[] numArray1 = new double[] { edge.get_Domain().ParameterAt(0.5) };
                    brep.get_Edges().SplitEdgeAtParameters(edge.get_EdgeIndex(), numArray1);
                }
                num--;
            }
        }
        
        public static void SplitSingularLoopsIntoTwoExotic(this Brep brep)
        {
            List<int> list = new List<int>();
            for (int i = brep.Loops.get_Count() - 1; i > -1; i--)
            {
                BrepLoop loop = brep.Loops.get_Item(i);
                if (loop.get_Trims().get_Count() == 1)
                {
                    BrepEdge edge = loop.get_Trims().get_Item(0).get_Edge();
                }
            }
        }
        
        public static void TrueClean(ref Brep brep)
        {
            brep = brep.SelectFaces((from x in brep.get_Faces() select x.get_FaceIndex()).ToList<int>());
        }
        
        [Serializable, CompilerGenerated]
        private sealed class <>c
        {
            public static readonly BrepFunctions.<>c <>9 = new BrepFunctions.<>c();
            public static Func<BrepFace, int> <>9__10_0;
            
            internal int <TrueClean>b__10_0(BrepFace x) => 
                x.get_FaceIndex();
        }
    }
}
