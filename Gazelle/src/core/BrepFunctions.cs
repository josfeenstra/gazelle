// Generated by .NET Reflector from D:\Sfered\Gazelle\Remnants\SferedApi_brep_manipulation.dll
using Rhino.Geometry;
using Rhino.Geometry.Intersect;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Gazelle
{

    
    public static class BrepFunctions
    {
        public static List<string> Log = new List<string>();
        
        public static void AddBrep(this Brep brep, Brep other)
        {
            brep.Append(other);
        }
        
        public static int AddCurve2D(this Brep brep, int edge, int loop, out bool isTrimReversedEdge)
        {
            BrepLoop loop2 = brep.Loops[loop];
            BrepFace face = loop2.Face;
            Curve curve = brep.Surfaces[face.SurfaceIndex].Pullback(
                brep.Edges[edge].DuplicateCurve(), 0.001
                );
            CurveOrientation orientation = (loop2.LoopType != (BrepLoopType)1) ? 
                ((loop2.LoopType != (BrepLoopType) 2) ? ((CurveOrientation) 0) : ((CurveOrientation) (-1))) 
                : ((CurveOrientation) 1);
            CurveOrientation orientation2 = curve.ClosedCurveOrientation(Plane.WorldXY);
            curve.Reverse();
            isTrimReversedEdge = true;
            if (((orientation2 != (CurveOrientation) 1)  || (orientation != (CurveOrientation) (-1))) ? 
                ((orientation2 == (CurveOrientation) (-1)) && (orientation == (CurveOrientation) 1))
                : true)
            {
                curve.Reverse();
                isTrimReversedEdge = !isTrimReversedEdge;
            }
            return brep.Curves2D.Add(curve);
        }
        
        public static int AddEdge(this Brep brep, Curve curve, int vertexFrom, int vertexTo)
        {
            int num = brep.Curves3D.Add(curve);
            return brep.Edges.Add(vertexFrom, vertexTo, num, 0.001).EdgeIndex;
        }
        
        public static int AddFace(this Brep brep, Surface surface)
        {
            int num = brep.AddSurface(surface);
            return brep.Faces.Add(num).FaceIndex;
        }
        
        public static int AddFace(this Brep brep, int surface, bool orientation = false)
        {
            BrepFace face = brep.Faces.Add(surface);
            face.OrientationIsReversed = orientation;
            return face.FaceIndex;
        }
        
        private static void AddIfNotInOther(this HashSet<int> set, int item, HashSet<int> other)
        {
            if (other.Contains(item))
            {
                Print<string>("OVERLAPPING ITEM THATS UNUSUAL");
            }
            set.Add(item);
        }
        
        public static int AddLoop(this Brep brep, int face, BrepLoopType type)
        {
            BrepFace face2 = brep.Faces[face];
            return brep.Loops.Add(type, face2).LoopIndex;
        }
        
        public static int AddOrientedTrim(Brep brep, int edge, int loop, IsoStatus status, BrepTrimType type)
        {
            int num;
            return AddOrientedTrim(brep, edge, loop, status, type, out num);
        }
        
        public static int AddOrientedTrim(Brep brep, int edge, int loop, IsoStatus status, BrepTrimType type, out int curveID)
        {
            bool flag;
            curveID = brep.AddCurve2D(edge, loop, out flag);
            return brep.AddTrim(edge, loop, flag, curveID, status, type);
        }
        
        public static int AddTrim(this Brep brep, int edge, int loop, bool isTrimReversedEdge, int curve2D, IsoStatus status, BrepTrimType type)
        {
            BrepEdge edge2 = brep.Edges[edge];
            BrepLoop loop2 = brep.Loops[loop];
            BrepFace face = loop2.Face;
            Surface surface = brep.Surfaces[face.SurfaceIndex];
            BrepTrim trim = brep.Trims.Add(edge2, isTrimReversedEdge, loop2, curve2D);
            trim.IsoStatus = status;
            trim.TrimType = type;
            trim.SetTolerances(0.001, 0.001);
            return trim.TrimIndex;
        }
        
        public static int AddTrimDepricated(this Brep brep, int edge, int loop, bool isTrimReversedEdge, bool flipTrim, IsoStatus status, BrepTrimType type)
        {
            BrepEdge edge2 = brep.Edges[edge];
            BrepLoop loop2 = brep.Loops[loop];
            BrepFace face = loop2.Face;
            Curve curve = brep.Surfaces[face.SurfaceIndex].Pullback(edge2.DuplicateCurve(), 0.001);
            if (flipTrim)
            {
                curve.Reverse();
            }
            BrepTrim trim = brep.Trims.Add(edge2, isTrimReversedEdge, loop2, brep.Curves2D.Add(curve));
            trim.IsoStatus = status;
            trim.TrimType = type;
            trim.SetTolerances(0.001, 0.001);
            return trim.TrimIndex;
        }
        
        public static int AddVertex(this Brep brep, Point3d point) => 
            brep.Vertices.Add(point, 0.0).VertexIndex;
        
        public static void AppendAt(this Brep brep, Brep other, Dictionary<int, int> edgeMap)
        {
            using (IEnumerator<BrepFace> enumerator = other.Faces.GetEnumerator())
            {
                while (true)
                {
                    if (!enumerator.MoveNext())
                    {
                        break;
                    }
                    BrepFace current = enumerator.Current;
                    foreach (BrepLoop loop in current.Loops)
                    {
                        foreach (BrepTrim trim in loop.Trims)
                        {
                        }
                    }
                }
            }
        }
        
        public static int BuildInnerFace(this Brep brep, int face, Curve curve)
        {
            int num = brep.BuildInnerLoop(face, curve, (BrepTrimType)2);
            BrepTrim trim = brep.Trims[num];
            BrepFace face2 = trim.Loop.Face;
            Surface surface = brep.Surfaces[face2.SurfaceIndex];
            int edge = trim.Edge.EdgeIndex;
            int num3 = brep.AddFace(face2.SurfaceIndex, false);
            int num5 = AddOrientedTrim(brep, edge, brep.AddLoop(num3, BrepLoopType.Outer), 0, (BrepTrimType)2);
            return num3;
        }
        
        private static int BuildInnerFace(ref Brep brep, int face, int edge)
        {
            int num2;
            int num = brep.BuildInnerLoop(face, edge, (BrepTrimType)2, out num2);
            BrepTrim trim = brep.Trims[num];
            BrepFace face2 = trim.Loop.Face;
            Surface surface = brep.Surfaces[face2.SurfaceIndex];
            int num3 = trim.Edge.EdgeIndex;
            int num4 = brep.AddFace(face2.SurfaceIndex, false);
            int num6 = AddOrientedTrim(brep, num3, brep.AddLoop(num4, (BrepLoopType)1), 0, (BrepTrimType)2);
            return num4;
        }
        
        public static int BuildInnerFacePreservingCurve(this Brep brep, int face, Curve curve)
        {
            int num2;
            int num = brep.BuildInnerLoop(face, curve, (BrepTrimType)2, out num2);
            BrepTrim trim = brep.Trims[num];
            BrepFace face2 = trim.Loop.Face;
            Surface surface = brep.Surfaces[face2.SurfaceIndex];
            int edge = trim.Edge.EdgeIndex;
            int num4 = brep.AddFace(face2.SurfaceIndex, false);
            int num6 = brep.AddTrim(edge, brep.AddLoop(num4, (BrepLoopType)1), trim.IsReversed(), num2, 0, (BrepTrimType)2);
            return num4;
        }
        
        public static List<int> BuildInnerFaces(this Brep brep, int face, List<Curve> curves)
        {
            int[] source = new int[curves.Count];
            for (int i = 0; i < curves.Count; i++)
            {
                source[i] = brep.BuildInnerFace(face, curves[i]);
            }
            return source.ToList<int>();
        }
        
        public static int BuildInnerLoop(this Brep brep, int face, Curve curve, BrepTrimType type = (BrepTrimType)1)
        {
            int num;
            return brep.BuildInnerLoop(face, curve, type, out num);
        }
        
        public static int BuildInnerLoop(this Brep brep, int face, Curve curve, BrepTrimType type, out int curveID)
        {
            if (!curve.IsClosed)
            {
                throw new Exception("Curve is not closed");
            }
            int vertexFrom = brep.AddVertex(curve.PointAtStart);
            int edge = brep.AddEdge(curve, vertexFrom, vertexFrom);
            int num3 = face;
            return AddOrientedTrim(brep, edge, brep.AddLoop(num3, (BrepLoopType)2), 0, type, out curveID);
        }
        
        public static int BuildInnerLoop(this Brep brep, int face, int edge, BrepTrimType type, out int curveID)
        {
            int num = edge;
            int num2 = face;
            return AddOrientedTrim(brep, num, brep.AddLoop(num2, (BrepLoopType)2), 0, type, out curveID);
        }
        
        public static List<int> BuildInnerLoops(this Brep brep, int face, List<Curve> curves, BrepTrimType type = (BrepTrimType)1)
        {
            int[] source = new int[curves.Count];
            for (int i = 0; i < curves.Count; i++)
            {
                source[i] = brep.BuildInnerLoop(face, curves[i], type);
            }
            return source.ToList<int>();
        }
        
        public static int CopyTrimWithCurve(Brep brep, BrepTrim original)
        {
            double num2;
            double num3;
            int num = brep.AddTrimCurve(original.DuplicateCurve());
            BrepTrim trim = brep.Trims.Add(original.Edge, original.IsReversed(), original.Loop, num);
            trim.IsoStatus = original.IsoStatus;
            trim.TrimType = trim.TrimType;
            trim.GetTolerances(out num2, out num3);
            double num4 = 1E-07;
            if (num2 < num4)
            {
                num2 = num4;
            }
            if (num3 < num4)
            {
                num3 = num4;
            }
            trim.SetTolerances(num2, num3);
            return trim.TrimIndex;
        }
        
        public static void CullUnusedEverything(this Brep brep)
        {
            brep.Compact();
        }
        
        public static Brep DeepCopy(Brep original, double precision)
        {
            Brep brep = new Brep();
            foreach (Surface surface in original.Surfaces)
            {
                brep.AddSurface(surface.Duplicate() as Surface);
            }
            foreach (BrepVertex vertex in original.Vertices)
            {
                brep.Vertices.Add(vertex.Location, precision);
            }
            foreach (BrepEdge edge in original.Edges)
            {
                brep.AddEdge(edge.DuplicateCurve(), edge.StartVertex.VertexIndex, edge.EndVertex.VertexIndex);
            }
            foreach (BrepFace face in original.Faces)
            {
                brep.AddFace(face.SurfaceIndex, face.OrientationIsReversed);
            }
            foreach (BrepLoop loop in original.Loops)
            {
                brep.AddLoop(loop.Face.FaceIndex, loop.LoopType);
            }
            foreach (BrepTrim trim in original.Trims)
            {
                CopyTrimWithCurve(brep, trim);
            }
            return brep;
        }
        
        public static Brep DeselectFaces(this Brep brep, List<int> faces)
        {
            List<int> list = new List<int>();
            for (int i = 0; i < brep.Faces.Count; i++)
            {
                if (!faces.Contains(i))
                {
                    list.Add(i);
                }
            }
            return brep.SelectFaces(list);
        }
        
        public static void DetectInsertions(Brep brep, out int[] innerFaces, out int[] outerFaces)
        {
            Flush();
            HashSet<int> inner = new HashSet<int>();
            HashSet<int> outer = new HashSet<int>();
            HashSet<int> set = new HashSet<int>();
            foreach (BrepEdge edge in brep.Edges)
            {
                Print<string>($"edge: {edge.EdgeIndex}");
                if (edge.Valence == (EdgeAdjacency)2)
                {
                    int[] numArray = edge.TrimIndices();
                    if (numArray.Length != 2)
                    {
                        Print<string>("Not two trims");
                        continue;
                    }
                    BrepTrim trim = brep.Trims[numArray[0]];
                    BrepTrim trim2 = brep.Trims[numArray[1]];
                    if (trim.Face == trim2.Face)
                    {
                        Print<string>("Same Face");
                        continue;
                    }
                    if (trim.Face.SurfaceIndex == trim2.Face.SurfaceIndex)
                    {
                        bool flag = trim.IsReversed();
                        if (flag == trim2.IsReversed())
                        {
                            Print<string>("SAME ORIENTATION THATS UNUSUAL");
                            continue;
                        }
                        set.Add(trim.Face.FaceIndex);
                        set.Add(trim2.Face.FaceIndex);
                        if (flag)
                        {
                            inner.AddIfNotInOther(trim2.Face.FaceIndex, outer);
                            outer.AddIfNotInOther(trim.Face.FaceIndex, inner);
                            continue;
                        }
                        inner.AddIfNotInOther(trim.Face.FaceIndex, outer);
                        outer.AddIfNotInOther(trim2.Face.FaceIndex, inner);
                    }
                }
            }
            foreach (BrepFace face in brep.Faces)
            {
                if (!set.Contains(face.FaceIndex))
                {
                    Print<string>("Leftover: " + face.FaceIndex.ToString());
                    if (face.AdjacentFaces().All(x => !outer.Contains(x)))
                    {
                        inner.Add(face.FaceIndex);
                    }
                    if (face.AdjacentFaces().All(x => !inner.Contains(x)))
                    {
                        outer.Add(face.FaceIndex);
                    }
                }
            }
            innerFaces = inner.ToArray<int>();
            outerFaces = outer.ToArray<int>();
        }
        
        public static void EmbedCurves(ref Brep brep, List<Curve> curves, out List<List<int>> edges, out List<int> faces)
        {
            int num = brep.Edges.Count;
            int num3 = num + curves.Count;
            edges = new List<List<int>>();
            faces = new List<int>();
            foreach (Curve curve in curves)
            {
                int vertexFrom = brep.AddVertex(curve.PointAtStart);
                int num5 = brep.AddEdge(curve, vertexFrom, vertexFrom);
            }
            Dictionary<int, EdgeSplitter> dictionary = new Dictionary<int, EdgeSplitter>();
            int edge = num;
            while (true)
            {
                bool flag;
                int num7;
                while (true)
                {
                    if (edge < num3)
                    {
                        flag = true;
                        num7 = 0;
                        break;
                    }
                    foreach (int num9 in dictionary.Keys)
                    {
                        dictionary[num9].Split();
                    }
                    TrueClean(ref brep);
                    return;
                }
                while (true)
                {
                    if (num7 >= num)
                    {
                        if (flag)
                        {
                            int face = brep.PointOnFace(brep.Edges[edge].PointAtStart);
                            if (face != -1)
                            {
                                faces.Add(BuildInnerFace(ref brep, face, edge));
                            }
                        }
                        edge++;
                        break;
                    }
                    CurveIntersections intersections = Intersection.CurveCurve(brep.Edges[edge], brep.Edges[num7], 0.001, 0.001);
                    if (intersections.Count > 0)
                    {
                        flag = false;
                        if (!dictionary.ContainsKey(edge))
                        {
                            dictionary[edge] = new EdgeSplitter(brep, edge, true);
                        }
                        if (!dictionary.ContainsKey(num7))
                        {
                            dictionary[num7] = new EdgeSplitter(brep, num7, false);
                        }
                        foreach (IntersectionEvent event2 in intersections)
                        {
                            dictionary[edge].AddIntersect(dictionary[num7], event2);
                        }
                    }
                    num7++;
                }
            }
        }
        
        public static Brep EmbedCurvesBeun(Brep brep, List<Curve> curves)
        {
            List<Brep> list = new List<Brep>();
            foreach (BrepFace face in brep.Faces)
            {
                Brep item = face.Split(curves, 0.001);
                list.Add(item);
            }
            Brep[] brepArray = Brep.JoinBreps(list, 0.001);
            if (brepArray.Length != 1)
            {
                throw new Exception("Joined brep is loose!");
            }
            return brepArray[0];
        }
        
        public static Brep EmbedCurvesOnFace(Brep brep, List<Curve> curves, int FaceIndex) => 
            null;
        
        private static List<int> EmbedCurvesToFace(Brep brep, List<Curve> curves, int face) => 
            new List<int>();
        
        public static void Extrude(this Brep brep, Vector3d direction)
        {
            List<int> list;
            List<int> list2;
            List<bool> list3;
            int num = brep.Vertices.Count;
            int num2 = brep.Edges.Count;
            brep.GetNakedItems(out list, out list2, out list3);
            Brep brep2 = brep.DuplicateBrep();
            brep2.Translate(direction);
            brep2.Faces.Flip(false);
            brep.Append(brep2);
            int num3 = 0;
            while (true)
            {
                if (num3 >= list.Count)
                {
                    TrueClean(ref brep);
                    return;
                }
                int num4 = list[num3];
                int num5 = num4 + num2;
                bool flag = list3[num3];
                brep.Faces.AddRuledFace(brep.Edges[num4], flag, brep.Edges[num5], flag);
                num3++;
            }
        }
        
        public static Brep ExtrudeFaces(this Brep brep, List<int> faces, Vector3d direction)
        {
            brep = brep.DuplicateBrep();
            int num = brep.Edges.Count;
            int num2 = brep.Faces.Count;
            List<int> faceEdges = brep.GetFaceEdges(faces);
            Brep brep2 = brep.DuplicateBrep();
            Brep brep3 = brep.SelectFaces(faces);
            brep2.Translate(direction);
            brep.Append(brep2);
            int num3 = 0;
            while (true)
            {
                if (num3 >= faceEdges.Count)
                {
                    List<int> collection = new List<int>();
                    int item = 0;
                    while (true)
                    {
                        if (item >= num2)
                        {
                            faces.AddRange(collection);
                            brep = brep.DeselectFaces(faces);
                            return brep;
                        }
                        if (!faces.Contains(item))
                        {
                            collection.Add(item + num2);
                        }
                        item++;
                    }
                }
                int num4 = faceEdges[num3];
                int num5 = num + num4;
                BrepEdge edge = brep.Edges[num4];
                BrepEdge edge2 = brep.Edges[num5];
                bool flag = false;
                if ((edge2.TrimCount == 1) && 
                    (brep.Trims[edge2.TrimIndices()[0]].Loop.LoopType == BrepLoopType.Inner))
                {
                    flag = true;
                }
                brep.Faces.AddRuledFace(edge, flag, edge2, flag);
                num3++;
            }
        }
        
        public static void ExtrudeNoCap(this Brep brep, Vector3d direction)
        {
            List<int> list;
            List<int> list2;
            List<bool> list3;
            int num = brep.Vertices.Count;
            int num2 = brep.Edges.Count;
            int num3 = brep.Faces.Count;
            brep.GetNakedItems(out list, out list2, out list3);
            Brep brep2 = brep.DuplicateBrep();
            brep2.Translate(direction);
            brep2.Faces.Flip(false);
            brep.Append(brep2);
            int num4 = 0;
            while (true)
            {
                if (num4 >= list.Count)
                {
                    List<int> faces = new List<int>();
                    int item = num3;
                    while (true)
                    {
                        if (item >= brep.Faces.Count)
                        {
                            brep = brep.SelectFaces(faces);
                            TrueClean(ref brep);
                            return;
                        }
                        faces.Add(item);
                        item++;
                    }
                }
                int num5 = list[num4];
                int num6 = num5 + num2;
                bool flag = list3[num4];
                brep.Faces.AddRuledFace(brep.Edges[num5], flag, brep.Edges[num6], flag);
                num4++;
            }
        }
        
        public static BrepFace FlipAFace(BrepFace face)
        {
            face.OrientationIsReversed = !face.OrientationIsReversed;
            return face;
        }
        
        public static Brep FlipFace(Brep brep, int i)
        {
            brep.Faces[i].OrientationIsReversed = !brep.Faces[i].OrientationIsReversed;
            return brep;
        }
        
        public static Brep FlipFaces(Brep brep, List<int> faceInts)
        {
            foreach (int num in faceInts)
            {
                FlipFace(brep, num);
            }
            return brep;
        }
        
        private static void Flush()
        {
            Log = new List<string>();
        }
        
        public static List<int> GetFaceEdges(this Brep brep, List<int> faces)
        {
            HashSet<int> source = new HashSet<int>();
            foreach (int num in faces)
            {
                BrepFace face = brep.Faces[num];
                foreach (int num3 in face.AdjacentEdges())
                {
                    BrepEdge edge = brep.Edges[num3];
                    int[] numArray2 = edge.AdjacentFaces();
                    if (edge.Valence == (EdgeAdjacency)1)
                    {
                        source.Add(num3);
                    }
                    else
                    {
                        if (!numArray2.All(x => faces.Contains(x)))
                        {
                            source.Add(num3);
                        }
                    }
                }
            }
            return source.ToList<int>();
        }
        
        public static List<int> GetFacesToFlip(Brep brep, int faceStart)
        {
            List<int> list = new List<int>();
            Queue<Tuple<int, bool>> queue = new Queue<Tuple<int, bool>>();
            HashSet<int> set = new HashSet<int>();
            queue.Enqueue(new Tuple<int, bool>(faceStart, false));
            while (queue.Count > 0)
            {
                Tuple<int, bool> tuple = queue.Dequeue();
                int item = tuple.Item1;
                bool flag = tuple.Item2;
                set.Add(item);
                Print<string>($"visiting face {item}. this face must be flipped : {flag}");
                if (flag)
                {
                    list.Add(item);
                }
                BrepFace face = brep.Faces[item];
                int[] second = face.AdjacentEdges();
                foreach (int num3 in face.AdjacentFaces())
                {
                    if (!set.Contains(num3))
                    {
                        IEnumerable<int> source = brep.Faces[num3].AdjacentEdges().Intersect<int>(second);
                        if (source.Count<int>() == 1)
                        {
                            bool flag3;
                            int num4 = source.FirstOrDefault<int>();
                            if (!IsEdgeOrientationBoundary(brep.Edges[num4]))
                            {
                                flag3 = flag;
                            }
                            else
                            {
                                Print<string>("found orientation boundary!");
                                flag3 = !flag;
                            }
                            Print<string>($"adding neighbour {num3}. this face must be flipped : {flag3}");
                            queue.Enqueue(new Tuple<int, bool>(num3, flag3));
                            set.Add(num3);
                        }
                    }
                }
            }
            return list;
        }
        
        public static void GetNakedItems(this Brep brep, out List<int> edges)
        {
            edges = new List<int>();
            foreach (BrepEdge edge in brep.Edges)
            {
                if (edge.Valence == (EdgeAdjacency)1)
                {
                    edges.Add(edge.EdgeIndex);
                }
            }
        }
        
        public static void GetNakedItems(this Brep brep, out List<int> edges, out List<int> vertices, out List<bool> edgeFlags)
        {
            edges = new List<int>();
            edgeFlags = new List<bool>();
            HashSet<int> source = new HashSet<int>();
            foreach (BrepEdge edge in brep.Edges)
            {
                if (edge.Valence == (EdgeAdjacency)1)
                {
                    bool item = brep.Trims[edge.TrimIndices()[0]].Loop.LoopType == BrepLoopType.Outer;
                    edges.Add(edge.EdgeIndex);
                    edgeFlags.Add(item);
                    source.Add(edge.StartVertex.VertexIndex);
                    source.Add(edge.EndVertex.VertexIndex);
                }
            }
            vertices = source.ToList<int>();
        }
        
        public static List<int> GetOrientationBoundaryEdges(Brep brep)
        {
            List<int> list = new List<int>();
            foreach (BrepEdge edge in brep.Edges)
            {
                if (IsEdgeOrientationBoundary(edge))
                {
                    list.Add(edge.EdgeIndex);
                }
            }
            return list;
        }

        public static bool IsEdgeOrientationBoundary(BrepEdge edge)
        {
            bool flag4;
            int[] source = edge.TrimIndices();
            if (source.Count<int>() != 2)
            {
                Print<string>("GetOrientationBoundaryEdges found an edge with more than 2 trims.");
                flag4 = false;
            }
            else
            {
                BrepTrim trim = edge.Brep.Trims[source[0]];
                BrepTrim trim2 = edge.Brep.Trims[source[1]];
                if (((trim.Loop.LoopType != (BrepLoopType)1) || (trim2.Loop.LoopType != (BrepLoopType)2)) ?
                    ((trim.Loop.LoopType == (BrepLoopType)2) && (trim2.Loop.LoopType == (BrepLoopType)1)) : true)
                {
                }
                bool flag = trim.IsReversed();
                if (trim.Loop.Face.OrientationIsReversed)
                {
                    flag = !flag;
                }
                bool flag2 = trim2.IsReversed();
                if (trim2.Loop.Face.OrientationIsReversed)
                {
                    flag2 = !flag2;
                }
                flag4 = flag == flag2;
            }
            return flag4;
        }
        
        public static Brep Join(this IEnumerable<Brep> breps)
        {
            Brep[] brepArray = Brep.JoinBreps(breps, 0.001);
            if (brepArray.Length != 1)
            {
                throw new Exception("join failed.");
            }
            return brepArray[0];
        }
        
        public static void JoinEdges(this Brep brep, int edgeIndex1, int edgeIndex2)
        {
            BrepEdge edge = brep.Edges[edgeIndex1];
            foreach (int num2 in brep.Edges[edgeIndex2].TrimIndices())
            {
                BrepTrim trim = brep.Trims[num2];
            }
        }
        
        public static Brep JoinNakedEdges(Brep original)
        {
            Brep brep = DeepCopy(original, 0.001);
            brep.JoinNakedEdges(0.001);
            return brep;
        }
        
        private static List<T> NotIn<T>(List<T> one, List<T> two)
        {
            List<T> list = new List<T>();
            for (int i = 0; i < one.Count; i++)
            {
                if (!two.Contains(one[i]))
                {
                    list.Add(one[i]);
                }
            }
            return list;
        }
        
        public static Brep[] PartitionFaces(this Brep brep, List<int> faces) => 
            new Brep[] { brep.SelectFaces(faces), brep.DeselectFaces(faces) };
        
        public static int PointOnFace(this Brep brep, Point3d point)
        {
            using (IEnumerator<BrepFace> enumerator = brep.Faces.GetEnumerator())
            {
                while (true)
                {
                    double num;
                    double num2;
                    if (!enumerator.MoveNext())
                    {
                        break;
                    }
                    BrepFace current = enumerator.Current;
                    bool flag = brep.Surfaces[current.SurfaceIndex].ClosestPoint(point, out num, out num2);
                    if (flag && (current.IsPointOnFace(num, num2) == (PointFaceRelation)1))
                    {
                        return current.FaceIndex;
                    }
                }
            }
            return -1;
        }
        
        private static void Print<T>(T obj)
        {
            Log.Add(obj.ToString());
        }
        
        public static void ProjectEmbed(Brep brep, List<Curve> curves, Vector3d vector, out Brep[] result)
        {
            List<Brep> list = new List<Brep>();
            int num = 0;
            while (true)
            {
                int[] numArray;
                int[] numArray2;
                if (num >= brep.Faces.Count)
                {
                    result = Brep.JoinBreps(list, 0.001);
                    return;
                }
                BrepFace face = brep.Faces[num];
                Brep item = brep.SelectFace(num);
                Brep[] brepArray1 = new Brep[] { item };
                Curve[] curveArray = Curve.ProjectToBrep(curves, brepArray1, vector, 0.001, out numArray, out numArray2);
                Brep brep3 = item.Faces[0].Split(curveArray, 0.001);
                if (brep3 == null)
                {
                    list.Add(item);
                }
                else
                {
                    list.Add(brep3);
                }
                num++;
            }
        }
        
        public static void RemoveEdge(this Brep brep, int edgeIndex, bool recurse = false)
        {
        }
        
        public static void RemoveFace(this Brep brep, int face)
        {
            throw new NotImplementedException();
        }
        
        public static void RemoveFace(this Brep brep, int faceIndex, bool recurse = false)
        {
        }
        
        public static void RemoveFaces(this Brep brep, List<int> faces)
        {
            throw new NotImplementedException();
        }
        
        public static void RemoveLoop(this Brep brep, int loopIndex, bool recurse = false)
        {
        }
        
        public static void RemoveTrim(this Brep brep, int trimIndex, bool recurse = false)
        {
        }
        
        public static void RemoveVertex(this Brep brep, int vertexIndex, bool recurse = false)
        {
        }
        
        public static Brep ReorientFaces(Brep original, int faceStart)
        {
            Brep brep = DeepCopy(original, 0.001);
            FlipFaces(brep, GetFacesToFlip(brep, faceStart));
            return brep;
        }
        
        public static Brep SelectFace(this Brep brep, int face)
        {
            int[] numArray1 = new int[] { face };
            return brep.DuplicateSubBrep(numArray1);
        }
        
        public static Brep SelectFaces(this Brep brep, List<int> faces) => 
            brep.DuplicateSubBrep(faces);
        
        public static Brep SelectFacesDepri(this Brep oldBrep, List<int> faces)
        {
            Brep brep = new Brep();
            Dictionary<int, int> dictionary = new Dictionary<int, int>();
            Dictionary<int, int> dictionary2 = new Dictionary<int, int>();
            Dictionary<int, int> dictionary3 = new Dictionary<int, int>();
            using (List<int>.Enumerator enumerator = faces.GetEnumerator())
            {
                while (true)
                {
                    if (!enumerator.MoveNext())
                    {
                        break;
                    }
                    int current = enumerator.Current;
                    BrepFace face = oldBrep.Faces[current];
                    int key = face.SurfaceIndex;
                    if (!dictionary3.ContainsKey(key))
                    {
                        dictionary3.Add(key, brep.AddSurface(face.DuplicateSurface()));
                    }
                    int num3 = brep.AddFace(dictionary3[key], false);
                    foreach (BrepLoop loop in face.Loops)
                    {
                        int num5 = brep.AddLoop(num3, loop.LoopType);
                        foreach (BrepTrim trim in loop.Trims)
                        {
                            BrepVertex[] vertexArray = new BrepVertex[] { trim.Edge.StartVertex, trim.Edge.EndVertex };
                            int index = 0;
                            while (true)
                            {
                                if (index >= vertexArray.Length)
                                {
                                    BrepEdge edge = trim.Edge;
                                    int num6 = edge.EdgeIndex;
                                    if (!dictionary2.ContainsKey(num6))
                                    {
                                        int vertexFrom = dictionary[edge.StartVertex.VertexIndex];
                                        dictionary2.Add(num6, brep.AddEdge(edge.DuplicateCurve(), vertexFrom, dictionary[edge.EndVertex.VertexIndex]));
                                    }
                                    int num7 = AddOrientedTrim(brep, dictionary2[num6], num5, trim.IsoStatus, trim.TrimType);
                                    break;
                                }
                                BrepVertex vertex = vertexArray[index];
                                if (!dictionary.ContainsKey(vertex.VertexIndex))
                                {
                                    int num9 = brep.AddVertex(vertex.Location);
                                    dictionary.Add(vertex.VertexIndex, num9);
                                }
                                index++;
                            }
                        }
                    }
                }
            }
            return brep;
        }
        
        public static Brep SelectFacesDepricated(this Brep oldBrep, List<int> faces)
        {
            Brep brep = new Brep();
            Dictionary<int, int> dictionary = new Dictionary<int, int>();
            Dictionary<int, int> dictionary2 = new Dictionary<int, int>();
            Dictionary<int, int> dictionary3 = new Dictionary<int, int>();
            using (List<int>.Enumerator enumerator = faces.GetEnumerator())
            {
                while (true)
                {
                    if (!enumerator.MoveNext())
                    {
                        break;
                    }
                    int current = enumerator.Current;
                    BrepFace face = oldBrep.Faces[current];
                    int key = face.SurfaceIndex;
                    if (!dictionary3.ContainsKey(key))
                    {
                        dictionary3.Add(key, brep.AddSurface(face.DuplicateSurface()));
                    }
                    int num3 = brep.AddFace(dictionary3[key], false);
                    foreach (BrepLoop loop in face.Loops)
                    {
                        int num5 = brep.AddLoop(num3, loop.LoopType);
                        foreach (BrepTrim trim in loop.Trims)
                        {
                            BrepVertex[] vertexArray = new BrepVertex[] { trim.Edge.StartVertex, trim.Edge.EndVertex };
                            int index = 0;
                            while (true)
                            {
                                if (index >= vertexArray.Length)
                                {
                                    BrepEdge edge = trim.Edge;
                                    int num6 = edge.EdgeIndex;
                                    if (!dictionary2.ContainsKey(num6))
                                    {
                                        int vertexFrom = dictionary[edge.StartVertex.VertexIndex];
                                        dictionary2.Add(num6, brep.AddEdge(edge.DuplicateCurve(), vertexFrom, dictionary[edge.EndVertex.VertexIndex]));
                                    }
                                    int num7 = AddOrientedTrim(brep, dictionary2[num6], num5, trim.IsoStatus, trim.TrimType);
                                    break;
                                }
                                BrepVertex vertex = vertexArray[index];
                                if (!dictionary.ContainsKey(vertex.VertexIndex))
                                {
                                    int num9 = brep.AddVertex(vertex.Location);
                                    dictionary.Add(vertex.VertexIndex, num9);
                                }
                                index++;
                            }
                        }
                    }
                }
            }
            return brep;
        }
        
        public static void SplitSingularLoopsIntoTwo(this Brep brep)
        {
            List<int> list = new List<int>();
            int num = brep.Loops.Count - 1;
            while (true)
            {
                if (num <= -1)
                {
                    brep.Standardize();
                    return;
                }
                BrepLoop loop = brep.Loops[num];
                if (loop.Trims.Count == 1)
                {
                    BrepEdge edge = loop.Trims[0].Edge;
                    double[] numArray1 = new double[] { edge.Domain.ParameterAt(0.5) };
                    brep.Edges.SplitEdgeAtParameters(edge.EdgeIndex, numArray1);
                }
                num--;
            }
        }
        
        public static void SplitSingularLoopsIntoTwoExotic(this Brep brep)
        {
            List<int> list = new List<int>();
            for (int i = brep.Loops.Count - 1; i > -1; i--)
            {
                BrepLoop loop = brep.Loops[i];
                if (loop.Trims.Count == 1)
                {
                    BrepEdge edge = loop.Trims[0].Edge;
                }
            }
        }
        
        public static void TrueClean(ref Brep brep)
        {
            brep = brep.SelectFaces((from x in brep.Faces select x.FaceIndex).ToList<int>());
        }
    }
}
