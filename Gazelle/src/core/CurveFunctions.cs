// Generated by .NET Reflector from D:\Sfered\Gazelle\Remnants\SferedApi_brep_manipulation.dll
namespace SferedApi
{
    using Grasshopper.Kernel.Types;
    using Rhino.Collections;
    using Rhino.Geometry;
    using Rhino.Geometry.Intersect;
    using System;
    using System.Collections.Generic;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;
    
    public static class CurveFunctions
    {
        private const double ROUGHLY_EQUAL_TOLERANCE = 0.0001;
        
        public static bool CutCurves(Curve curve, List<IGH_Goo> splitters, List<GH_Boolean> options, out List<double> tValues, out List<Point3d> splitPoints, out Curve[] subCurves, out List<string> errorMessage)
        {
            List<double> list;
            List<Point3d> list2;
            List<Plane> list3;
            List<Curve> list4;
            int num3;
            bool flag = false;
            bool flag2 = true;
            bool flag3 = false;
            bool flag4 = true;
            double num = 0.01;
            int num2 = 0;
            while (true)
            {
                if (num2 >= options.Count)
                {
                    errorMessage = new List<string>();
                    list = new List<double>();
                    list2 = new List<Point3d>();
                    list3 = new List<Plane>();
                    list4 = new List<Curve>();
                    tValues = new List<double>();
                    splitPoints = new List<Point3d>();
                    subCurves = null;
                    num3 = 0;
                    break;
                }
                if (num2 == 0)
                {
                    flag = options[num2].get_Value();
                }
                if (num2 == 1)
                {
                    flag2 = options[num2].get_Value();
                }
                if (num2 == 2)
                {
                    flag3 = options[num2].get_Value();
                    flag4 = false;
                }
                num2++;
            }
            while (true)
            {
                while (true)
                {
                    if (num3 < splitters.Count)
                    {
                        IGH_Goo goo = splitters[num3];
                        if (goo != null)
                        {
                            if (!(goo is GH_Number))
                            {
                                if (!(goo is GH_Point))
                                {
                                    if (!(goo is GH_Plane))
                                    {
                                        if (!(goo is GH_Curve))
                                        {
                                            errorMessage.Add($"Data of type {goo.get_TypeName()} could not be converted into a type of cutter. Index = {num3.ToString()}");
                                            return false;
                                        }
                                        else
                                        {
                                            Curve item = (goo as GH_Curve).get_Value();
                                            if (curve.get_IsClosed() && item.get_IsClosed())
                                            {
                                                list4.Add(item);
                                                foreach (IntersectionEvent event4 in Intersection.CurveCurve(curve, item, 0.001, 0.001))
                                                {
                                                    if (!event4.get_IsOverlap())
                                                    {
                                                        tValues.Add(event4.get_ParameterA());
                                                        continue;
                                                    }
                                                    tValues.Add(event4.get_OverlapA().get_Min());
                                                    tValues.Add(event4.get_OverlapA().get_Max());
                                                }
                                            }
                                            else
                                            {
                                                return false;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        Plane item = (goo as GH_Plane).get_Value();
                                        list3.Add(item);
                                        CurveIntersections intersections = Intersection.CurvePlane(curve, item, 0.001);
                                        if (intersections == null)
                                        {
                                            errorMessage.Add("Made Plane Adjustments");
                                            List<Point3d> list1 = new List<Point3d>();
                                            list1.Add(curve.get_PointAtStart());
                                            list1.Add(curve.get_PointAtEnd());
                                            Point3d pointd3 = Point3dList.ClosestPointInList(list1, item.get_Origin());
                                            if (flag4)
                                            {
                                                flag3 = pointd3 == curve.get_PointAtStart();
                                            }
                                            if (flag3)
                                            {
                                                tValues.Add(curve.get_Domain().get_T0());
                                            }
                                            else
                                            {
                                                tValues.Add(curve.get_Domain().get_T1());
                                            }
                                        }
                                        else if (!flag)
                                        {
                                            foreach (IntersectionEvent event3 in intersections)
                                            {
                                                tValues.Add(event3.get_ParameterA());
                                            }
                                        }
                                        else
                                        {
                                            double positiveInfinity = double.PositiveInfinity;
                                            double naN = double.NaN;
                                            foreach (IntersectionEvent event2 in intersections)
                                            {
                                                double num8 = item.get_Origin().DistanceTo(event2.get_PointA());
                                                if (num8 < positiveInfinity)
                                                {
                                                    positiveInfinity = num8;
                                                    naN = event2.get_ParameterA();
                                                }
                                            }
                                            tValues.Add(naN);
                                        }
                                    }
                                }
                                else
                                {
                                    double num5;
                                    Point3d item = (goo as GH_Point).get_Value();
                                    list2.Add(item);
                                    curve.ClosestPoint(item, ref num5);
                                    tValues.Add(num5);
                                }
                            }
                            else
                            {
                                double item = (goo as GH_Number).get_Value();
                                list.Add(item);
                                tValues.Add(item);
                            }
                        }
                    }
                    else
                    {
                        if (tValues.Count == 0)
                        {
                            errorMessage.Add("No intersections.");
                        }
                        if (flag2)
                        {
                            double num9 = num;
                            double num10 = curve.get_Domain().get_Min() + num9;
                            double num11 = curve.get_Domain().get_Max() - num9;
                            int num12 = 0;
                            while (true)
                            {
                                if (num12 >= tValues.Count)
                                {
                                    int num13 = tValues.Count - 1;
                                    while (true)
                                    {
                                        if (num13 < 0)
                                        {
                                            break;
                                        }
                                        if (tValues[num13] > num11)
                                        {
                                            tValues[num13] = num11;
                                            num11 = tValues[num13] - num9;
                                        }
                                        num13--;
                                    }
                                    break;
                                }
                                if (tValues[num12] < num10)
                                {
                                    tValues[num12] = num10;
                                    num10 = tValues[num12] + num9;
                                }
                                num12++;
                            }
                        }
                        foreach (double num14 in tValues)
                        {
                            splitPoints.Add(curve.PointAt(num14));
                        }
                        subCurves = curve.Split(tValues);
                        return true;
                    }
                    break;
                }
                num3++;
            }
        }
        
        public static bool DoCurvesTouch(Curve a, Curve b) => 
            Intersection.CurveCurve(a, b, 0.001, 0.0).get_Count() != 0;
        
        public static void FixDirections(ref Curve[] curves)
        {
            for (int i = 0; i < (curves.Length - 1); i++)
            {
                if (!VectorFunctions.IsSimilar(curves[i].get_PointAtEnd(), curves[i].get_PointAtStart()))
                {
                    curves[i + 1].Reverse();
                }
            }
        }
        
        public static bool IsTouching(Curve curve, BrepFace face)
        {
            Curve[] curveArray;
            Point3d[] pointdArray;
            Intersection.CurveBrepFace(curve, face, 0.001, ref curveArray, ref pointdArray);
            return ((curveArray.Length != 0) || (pointdArray.Length != 0));
        }
        
        public static Curve[] SplitAt(this Curve curve, double normParam)
        {
            Point3d pointd;
            return curve.SplitAt(normParam, out pointd);
        }
        
        public static Curve[] SplitAt(this Curve curve, double normParam, out Point3d cutPoint)
        {
            double num;
            if (!curve.NormalizedLengthParameter(normParam, ref num))
            {
                throw new Exception("normal param needs to be between 0 and 1");
            }
            Curve[] curveArray = curve.Split(num);
            cutPoint = curve.PointAtNormalizedLength(normParam);
            return curveArray;
        }
        
        public static void Swap<T>(ref T lhs, ref T rhs)
        {
            T local = lhs;
            lhs = rhs;
            rhs = local;
        }
        
        public static List<T> ToList<T>(IEnumerable<T> data)
        {
            List<T> list = new List<T>();
            foreach (T local in data)
            {
                list.Add(local);
            }
            return list;
        }
    }
}
